=== Starting test "AwsExplorer displays region nodes with user-friendly region names" ===
=== Ending test "AwsExplorer displays region nodes with user-friendly region names" ===

=== Starting test "AwsExplorer refreshes when the Region Provider is updated" ===
Refreshing AWS Explorer due to Region Provider updates
=== Ending test "AwsExplorer refreshes when the Region Provider is updated" ===

=== Starting test "RegionNode initializes name and tooltip" ===
=== Ending test "RegionNode initializes name and tooltip" ===

=== Starting test "RegionNode contains children" ===
=== Ending test "RegionNode contains children" ===

=== Starting test "RegionNode does not have child nodes for services not available in a region" ===
=== Ending test "RegionNode does not have child nodes for services not available in a region" ===

=== Starting test "detectCdkProjects detects no projects when workspaceFolders is undefined" ===
=== Ending test "detectCdkProjects detects no projects when workspaceFolders is undefined" ===

=== Starting test "detectCdkProjects detects no projects when workspaceFolders is empty" ===
=== Ending test "detectCdkProjects detects no projects when workspaceFolders is empty" ===

=== Starting test "detectCdkProjects detects no projects when cdk.json does not exist" ===
Error detecting CDK apps in /tmp/aws-toolkit-vscode/vsctk-cdkzRPqwD
Error: ENOENT: no such file or directory, access '/tmp/aws-toolkit-vscode/vsctk-cdkzRPqwD/cdk.json'
=== Ending test "detectCdkProjects detects no projects when cdk.json does not exist" ===

=== Starting test "detectCdkProjects detects CDK project when cdk.json exists" ===
=== Ending test "detectCdkProjects detects CDK project when cdk.json exists" ===

=== Starting test "detectCdkProjects detects CDK projects in multi-folder workspace" ===
=== Ending test "detectCdkProjects detects CDK projects in multi-folder workspace" ===

=== Starting test "AppNode initializes label and tooltip" ===
=== Ending test "AppNode initializes label and tooltip" ===

=== Starting test "AppNode initializes icon paths" ===
=== Ending test "AppNode initializes icon paths" ===

=== Starting test "AppNode returns placeholder node when app contains no stacks" ===
=== Ending test "AppNode returns placeholder node when app contains no stacks" ===

=== Starting test "AppNode returns construct node when app has stacks" ===
=== Ending test "AppNode returns construct node when app has stacks" ===

=== Starting test "AppNode returns placeholder node when tree.json cannot be loaded" ===
Could not load the construct tree located at 'rootcdk-project/cdk-test-folder/cdk.out/tree.json'
Error: Error
=== Ending test "AppNode returns placeholder node when tree.json cannot be loaded" ===

=== Starting test "AwsCdkExplorer Displays Error node indicating that no CDK projects were found in empty workspace" ===
=== Ending test "AwsCdkExplorer Displays Error node indicating that no CDK projects were found in empty workspace" ===

=== Starting test "AwsCdkExplorer Displays a project node when workspaces are detected" ===
=== Ending test "AwsCdkExplorer Displays a project node when workspaces are detected" ===

=== Starting test "ConstructNode initializes label and tooltip" ===
=== Ending test "ConstructNode initializes label and tooltip" ===

=== Starting test "ConstructNode returns id that includes parent's id and it's own label" ===
=== Ending test "ConstructNode returns id that includes parent's id and it's own label" ===

=== Starting test "ConstructNode initializes icon paths for CloudFormation resources" ===
=== Ending test "ConstructNode initializes icon paths for CloudFormation resources" ===

=== Starting test "ConstructNode initializes icon paths for CDK constructs" ===
=== Ending test "ConstructNode initializes icon paths for CDK constructs" ===

=== Starting test "ConstructNode returns no child nodes if construct does not have any" ===
=== Ending test "ConstructNode returns no child nodes if construct does not have any" ===

=== Starting test "ConstructNode child node has no collapsible state if it has no children or attributes" ===
=== Ending test "ConstructNode child node has no collapsible state if it has no children or attributes" ===

=== Starting test "ConstructNode child node is collapsed if construct has child with attributes" ===
=== Ending test "ConstructNode child node is collapsed if construct has child with attributes" ===

=== Starting test "ConstructNode returns child node of PropertyNode when construct has props" ===
=== Ending test "ConstructNode returns child node of PropertyNode when construct has props" ===

=== Starting test "ConstructNode returns child nodes of PropertyNode and ConstructNode when construct has props and children" ===
=== Ending test "ConstructNode returns child nodes of PropertyNode and ConstructNode when construct has props and children" ===

=== Starting test "ConstructNode returns child node if a construct has grandchildren" ===
=== Ending test "ConstructNode returns child node if a construct has grandchildren" ===

=== Starting test "CdkErrorNode initializes label and tooltip" ===
=== Ending test "CdkErrorNode initializes label and tooltip" ===

=== Starting test "CdkErrorNode has no children" ===
=== Ending test "CdkErrorNode has no children" ===

=== Starting test "PropertyNode initializes label" ===
=== Ending test "PropertyNode initializes label" ===

=== Starting test "PropertyNode initializes icon paths for properties" ===
=== Ending test "PropertyNode initializes icon paths for properties" ===

=== Starting test "PropertyNode returns no children when property does not have nested values" ===
=== Ending test "PropertyNode returns no children when property does not have nested values" ===

=== Starting test "PropertyNode returns single child when property has a string value" ===
=== Ending test "PropertyNode returns single child when property has a string value" ===

=== Starting test "PropertyNode returns single child when property has a boolean value" ===
=== Ending test "PropertyNode returns single child when property has a boolean value" ===

=== Starting test "PropertyNode returns single child when property has an int value" ===
=== Ending test "PropertyNode returns single child when property has an int value" ===

=== Starting test "PropertyNode returns a nested property node with a property node for each value in the array" ===
=== Ending test "PropertyNode returns a nested property node with a property node for each value in the array" ===

=== Starting test "PropertyNode returns a nested property node with nested object as child property nodes" ===
=== Ending test "PropertyNode returns a nested property node with nested object as child property nodes" ===

=== Starting test "TreeInspector returns label when construct is not named Resource" ===
=== Ending test "TreeInspector returns label when construct is not named Resource" ===

=== Starting test "TreeInspector includes type when construct is named Resource and type exists" ===
=== Ending test "TreeInspector includes type when construct is named Resource and type exists" ===

=== Starting test "TreeInspector returns unchanged label when construct is named Resource and no type information exists" ===
=== Ending test "TreeInspector returns unchanged label when construct is named Resource and no type information exists" ===

=== Starting test "TreeInspector returns default if no type information exists" ===
=== Ending test "TreeInspector returns default if no type information exists" ===

=== Starting test "TreeInspector returns type when type information exists" ===
=== Ending test "TreeInspector returns type when type information exists" ===

=== Starting test "TreeInspector includes construct in tree" ===
=== Ending test "TreeInspector includes construct in tree" ===

=== Starting test "TreeInspector excludes the `Tree` construct that the CDK adds by default" ===
=== Ending test "TreeInspector excludes the `Tree` construct that the CDK adds by default" ===

=== Starting test "TreeInspector returns properties when a construct has attributes" ===
=== Ending test "TreeInspector returns properties when a construct has attributes" ===

=== Starting test "TreeInspector returns undefined when construct does not have attributes" ===
=== Ending test "TreeInspector returns undefined when construct does not have attributes" ===

=== Starting test "TreeInspector returns undefined when construct does not have CloudFormation properties" ===
=== Ending test "TreeInspector returns undefined when construct does not have CloudFormation properties" ===

=== Starting test "updateCredentialsStatusBarItem updates text with credentials id" ===
=== Ending test "updateCredentialsStatusBarItem updates text with credentials id" ===

=== Starting test "updateCredentialsStatusBarItem updates text with placeholder when there is no credentials id" ===
=== Ending test "updateCredentialsStatusBarItem updates text with placeholder when there is no credentials id" ===

=== Starting test "BaseCredentialsProviderFactory can add a provider" ===
=== Ending test "BaseCredentialsProviderFactory can add a provider" ===

=== Starting test "BaseCredentialsProviderFactory can remove a provider" ===
=== Ending test "BaseCredentialsProviderFactory can remove a provider" ===

=== Starting test "BaseCredentialsProviderFactory can reset providers" ===
=== Ending test "BaseCredentialsProviderFactory can reset providers" ===

=== Starting test "BaseCredentialsProviderFactory can list providers" ===
=== Ending test "BaseCredentialsProviderFactory can list providers" ===

=== Starting test "BaseCredentialsProviderFactory returns a requested provider" ===
=== Ending test "BaseCredentialsProviderFactory returns a requested provider" ===

=== Starting test "BaseCredentialsProviderFactory returns undefined when requesting a provider it does not have" ===
=== Ending test "BaseCredentialsProviderFactory returns undefined when requesting a provider it does not have" ===

=== Starting test "CredentialsProviderId fromString produces CredentialsProviderId from a string" ===
=== Ending test "CredentialsProviderId fromString produces CredentialsProviderId from a string" ===

=== Starting test "CredentialsProviderId fromString supports cases where the separator is in the credentialTypeId" ===
=== Ending test "CredentialsProviderId fromString supports cases where the separator is in the credentialTypeId" ===

=== Starting test "CredentialsProviderId fromString errs on unexpected format - not enough separators" ===
=== Ending test "CredentialsProviderId fromString errs on unexpected format - not enough separators" ===

=== Starting test "CredentialsProviderId fromString errs on unexpected format - different separator" ===
=== Ending test "CredentialsProviderId fromString errs on unexpected format - different separator" ===

=== Starting test "CredentialsProviderId asString converts a CredentialsProviderId to a string" ===
=== Ending test "CredentialsProviderId asString converts a CredentialsProviderId to a string" ===

=== Starting test "CredentialsProviderId isEqual detects matches" ===
=== Ending test "CredentialsProviderId isEqual detects matches" ===

=== Starting test "CredentialsProviderId isEqual detects non-matches in credentialType" ===
=== Ending test "CredentialsProviderId isEqual detects non-matches in credentialType" ===

=== Starting test "CredentialsProviderId isEqual detects non-matches in credentialTypeId" ===
=== Ending test "CredentialsProviderId isEqual detects non-matches in credentialTypeId" ===

=== Starting test "CredentialsProviderManager getCredentialProviderNames()" ===
=== Ending test "CredentialsProviderManager getCredentialProviderNames()" ===

=== Starting test "CredentialsProviderManager getAllCredentialsProviders returns all providers" ===
=== Ending test "CredentialsProviderManager getAllCredentialsProviders returns all providers" ===

=== Starting test "CredentialsProviderManager getCredentialsProvider returns a provider" ===
=== Ending test "CredentialsProviderManager getCredentialsProvider returns a provider" ===

=== Starting test "CredentialsProviderManager getCredentialsProvider returns undefined when there is a factory but the factory does not contain a provider" ===
=== Ending test "CredentialsProviderManager getCredentialsProvider returns undefined when there is a factory but the factory does not contain a provider" ===

=== Starting test "CredentialsProviderManager getCredentialsProvider returns undefined when there is not a factory for the given credentialsType" ===
=== Ending test "CredentialsProviderManager getCredentialsProvider returns undefined when there is not a factory for the given credentialsType" ===

=== Starting test "SharedCredentialsProvider constructor fails if profile does not exist" ===
=== Ending test "SharedCredentialsProvider constructor fails if profile does not exist" ===

=== Starting test "SharedCredentialsProvider produces a CredentialsProviderId" ===
=== Ending test "SharedCredentialsProvider produces a CredentialsProviderId" ===

=== Starting test "SharedCredentialsProvider gets profile properties" ===
=== Ending test "SharedCredentialsProvider gets profile properties" ===

=== Starting test "SharedCredentialsProvider profile properties may be undefined" ===
=== Ending test "SharedCredentialsProvider profile properties may be undefined" ===

=== Starting test "SharedCredentialsProvider validation identifies a source_profile reference that does not exist" ===
=== Ending test "SharedCredentialsProvider validation identifies a source_profile reference that does not exist" ===

=== Starting test "SharedCredentialsProvider validation identifies a source_profile reference cycle" ===
=== Ending test "SharedCredentialsProvider validation identifies a source_profile reference cycle" ===

=== Starting test "SharedCredentialsProvider validation identifies when access key id is missing a corresponding secret key" ===
=== Ending test "SharedCredentialsProvider validation identifies when access key id is missing a corresponding secret key" ===

=== Starting test "SharedCredentialsProvider validation identifies when session_token is missing a corresponding access key id" ===
=== Ending test "SharedCredentialsProvider validation identifies when session_token is missing a corresponding access key id" ===

=== Starting test "SharedCredentialsProvider validation identifies when session_token is missing a corresponding secret key" ===
=== Ending test "SharedCredentialsProvider validation identifies when session_token is missing a corresponding secret key" ===

=== Starting test "SharedCredentialsProvider validation identifies when the profile contains no supported properties" ===
=== Ending test "SharedCredentialsProvider validation identifies when the profile contains no supported properties" ===

=== Starting test "SharedCredentialsProvider validates a valid profile with an access key" ===
=== Ending test "SharedCredentialsProvider validates a valid profile with an access key" ===

=== Starting test "SharedCredentialsProvider validates a valid profile with a session token" ===
=== Ending test "SharedCredentialsProvider validates a valid profile with a session token" ===

=== Starting test "SharedCredentialsProvider validates a valid profile with credential_process" ===
=== Ending test "SharedCredentialsProvider validates a valid profile with credential_process" ===

=== Starting test "SharedCredentialsProvider validates a valid profile with role_arn" ===
=== Ending test "SharedCredentialsProvider validates a valid profile with role_arn" ===

=== Starting test "SharedCredentialsProvider validates a valid profile with role_arn and source_profile" ===
=== Ending test "SharedCredentialsProvider validates a valid profile with role_arn and source_profile" ===

=== Starting test "SharedCredentialsProvider getCredentials throws when the profile is not valid" ===
=== Ending test "SharedCredentialsProvider getCredentials throws when the profile is not valid" ===

=== Starting test "SharedCredentialsProviderFactory produces credential providers from shared credentials profiles" ===
Loading all Shared Credentials Profiles
credentials: found profiles: default,alt
=== Ending test "SharedCredentialsProviderFactory produces credential providers from shared credentials profiles" ===

=== Starting test "SharedCredentialsProviderFactory does not load providers for invalid profiles" ===
Loading all Shared Credentials Profiles
credentials: found profiles: default,alt,gary
Shared Credentials Profile gary is not valid. It will not be used by the toolkit. Profile gary is missing properties: aws_secret_access_key
=== Ending test "SharedCredentialsProviderFactory does not load providers for invalid profiles" ===

=== Starting test "SharedCredentialsProviderFactory refresh does not reload from file if the file has not changed" ===
Loading all Shared Credentials Profiles
credentials: found profiles: default,alt
=== Ending test "SharedCredentialsProviderFactory refresh does not reload from file if the file has not changed" ===

=== Starting test "SharedCredentialsProviderFactory refresh reloads from file if the file has changed" ===
Loading all Shared Credentials Profiles
credentials: found profiles: default,alt
Loading all Shared Credentials Profiles
credentials: found profiles: default,alt
=== Ending test "SharedCredentialsProviderFactory refresh reloads from file if the file has changed" ===

=== Starting test "sharedCredentials getCredentialsFilename uses the default credentials path if AWS_SHARED_CREDENTIALS_FILE is not set" ===
=== Ending test "sharedCredentials getCredentialsFilename uses the default credentials path if AWS_SHARED_CREDENTIALS_FILE is not set" ===

=== Starting test "sharedCredentials getCredentialsFilename gets AWS_SHARED_CREDENTIALS_FILE if set" ===
=== Ending test "sharedCredentials getCredentialsFilename gets AWS_SHARED_CREDENTIALS_FILE if set" ===

=== Starting test "sharedCredentials getConfigFilename uses the default config path if AWS_CONFIG_FILE is not set" ===
=== Ending test "sharedCredentials getConfigFilename uses the default config path if AWS_CONFIG_FILE is not set" ===

=== Starting test "sharedCredentials getConfigFilename gets AWS_CONFIG_FILE if set" ===
=== Ending test "sharedCredentials getConfigFilename gets AWS_CONFIG_FILE if set" ===

=== Starting test "CodeDownloader codeDownloader should return an error if the response body is not Buffer" ===
=== Ending test "CodeDownloader codeDownloader should return an error if the response body is not Buffer" ===

=== Starting test "CodeDownloader codeDownloader should return arrayBuffer for valid Body type" ===
=== Ending test "CodeDownloader codeDownloader should return arrayBuffer for valid Body type" ===

=== Starting test "CodeGenerator codeGenerator should return the current status of code generation" ===
=== Ending test "CodeGenerator codeGenerator should return the current status of code generation" ===

=== Starting test "CodeGenerator codeGenerator should return valid code generation status if it gets ConflictException" ===
=== Ending test "CodeGenerator codeGenerator should return valid code generation status if it gets ConflictException" ===

=== Starting test "CodeGeneratorStatusPoller getCurrentStatus should return the current status of code generation" ===
=== Ending test "CodeGeneratorStatusPoller getCurrentStatus should return the current status of code generation" ===

=== Starting test "CodeGeneratorStatusPoller codeGeneratorStatusPoller fails if code generation status is invalid without retry" ===
=== Ending test "CodeGeneratorStatusPoller codeGeneratorStatusPoller fails if code generation status is invalid without retry" ===

=== Starting test "CodeGeneratorStatusPoller codeGeneratorStatusPoller times out after max attempts if status is still in progress" ===
=== Ending test "CodeGeneratorStatusPoller codeGeneratorStatusPoller times out after max attempts if status is still in progress" ===

=== Starting test "CodeGeneratorStatusPoller codeGeneratorStatusPoller succeeds when code is previously generated without retry" ===
=== Ending test "CodeGeneratorStatusPoller codeGeneratorStatusPoller succeeds when code is previously generated without retry" ===

=== Starting test "CodeGeneratorStatusPoller codeGeneratorStatusPoller succeeds once the code generation status is complete within maxRetry attempts" ===
=== Ending test "CodeGeneratorStatusPoller codeGeneratorStatusPoller succeeds once the code generation status is complete within maxRetry attempts" ===

=== Starting test "SchemaCodeDownload downloadCode should download pre-generated code and place it into requested directory " ===
=== Ending test "SchemaCodeDownload downloadCode should download pre-generated code and place it into requested directory " ===

=== Starting test "SchemaCodeDownload downloadCode should return error if downloading code fails with anything other than NotFoundException" ===
=== Ending test "SchemaCodeDownload downloadCode should return error if downloading code fails with anything other than NotFoundException" ===

=== Starting test "SchemaCodeDownload downloadCode should generate code if download fails with NotFoundException and place it into requested directory" ===
=== Ending test "SchemaCodeDownload downloadCode should generate code if download fails with NotFoundException and place it into requested directory" ===

=== Starting test "SchemaCodeDownload downloadCode should return coreCodeFilePath" ===
=== Ending test "SchemaCodeDownload downloadCode should return coreCodeFilePath" ===

=== Starting test "CodeExtractor validateNoFileCollisions can validate zipFile directoryFile contents clash " ===
=== Ending test "CodeExtractor validateNoFileCollisions can validate zipFile directoryFile contents clash " ===

=== Starting test "CodeExtractor validateNoFileCollisions should return true if no collision present" ===
=== Ending test "CodeExtractor validateNoFileCollisions should return true if no collision present" ===

=== Starting test "CodeExtractor extractAndPlace should extract files if no collision present" ===
=== Ending test "CodeExtractor extractAndPlace should extract files if no collision present" ===

=== Starting test "CodeExtractor extractAndPlace should not override file content if collision occurs" ===
=== Ending test "CodeExtractor extractAndPlace should not override file content if collision occurs" ===

=== Starting test "CodeExtractor extractAndPlace should return coreCodeFilePath if it exists inside zip content" ===
=== Ending test "CodeExtractor extractAndPlace should return coreCodeFilePath if it exists inside zip content" ===

=== Starting test "CodeExtractor getCoreCodeFilePath shoul return file path if it exists in zipFile" ===
=== Ending test "CodeExtractor getCoreCodeFilePath shoul return file path if it exists in zipFile" ===

=== Starting test "CodeExtractor getCoreCodeFilePath should return undefined if file does not exist in zipFile" ===
=== Ending test "CodeExtractor getCoreCodeFilePath should return undefined if file does not exist in zipFile" ===

=== Starting test "Search Schemas getSearchListForSingleRegistry should return summaries" ===
=== Ending test "Search Schemas getSearchListForSingleRegistry should return summaries" ===

=== Starting test "Search Schemas getSearchListForSingleRegistry should display an error message when search api call fails" ===
TypeError: Cannot read property 'Symbol(Symbol.asyncIterator)' of undefined
=== Ending test "Search Schemas getSearchListForSingleRegistry should display an error message when search api call fails" ===

=== Starting test "Search Schemas getSearchResults should display error message for failed registries and return summaries for successful ones" ===
TypeError: Cannot read property 'Symbol(Symbol.asyncIterator)' of undefined
TypeError: Cannot read property 'Symbol(Symbol.asyncIterator)' of undefined
=== Ending test "Search Schemas getSearchResults should display error message for failed registries and return summaries for successful ones" ===

=== Starting test "Search Schemas createMessageReceivedFunc shows schema content for latest matching schema version by default" ===
=== Ending test "Search Schemas createMessageReceivedFunc shows schema content for latest matching schema version by default" ===

=== Starting test "Search Schemas createMessageReceivedFunc shows schema content for user selected version" ===
=== Ending test "Search Schemas createMessageReceivedFunc shows schema content for user selected version" ===

=== Starting test "Search Schemas createMessageReceivedFunc shows schema list when user makes a search" ===
TypeError: Cannot read property 'Symbol(Symbol.asyncIterator)' of undefined
=== Ending test "Search Schemas createMessageReceivedFunc shows schema list when user makes a search" ===

=== Starting test "Search Schemas createMessageReceivedFunc throws an error for an invalid command message" ===
=== Ending test "Search Schemas createMessageReceivedFunc throws an error for an invalid command message" ===

=== Starting test "Search Schemas getRegistryNameList should return list with single registry name for registryItemNode" ===
=== Ending test "Search Schemas getRegistryNameList should return list with single registry name for registryItemNode" ===

=== Starting test "Search Schemas getRegistryNameList should return list with multiple registry names for schemasNode" ===
=== Ending test "Search Schemas getRegistryNameList should return list with multiple registry names for schemasNode" ===

=== Starting test "Search Schemas getRegistryNameList should return an empty list and display error message if schemas service not available in the region" ===
TypeError: Cannot read property 'Symbol(Symbol.asyncIterator)' of undefined
=== Ending test "Search Schemas getRegistryNameList should return an empty list and display error message if schemas service not available in the region" ===

=== Starting test "viewSchemaItem prettifies schema content and inserts into the editor " ===
=== Ending test "viewSchemaItem prettifies schema content and inserts into the editor " ===

=== Starting test "viewSchemaItem schemaFormatter can pretty print schema content" ===
=== Ending test "viewSchemaItem schemaFormatter can pretty print schema content" ===

=== Starting test "viewSchemaItem showSchemaContent inserts pretty schema content into an editor" ===
=== Ending test "viewSchemaItem showSchemaContent inserts pretty schema content into an editor" ===

=== Starting test "RegistryItemNode initializes name and tooltip" ===
=== Ending test "RegistryItemNode initializes name and tooltip" ===

=== Starting test "RegistryItemNode initializes icon" ===
=== Ending test "RegistryItemNode initializes icon" ===

=== Starting test "RegistryItemNode returns placeholder node if no children are present" ===
=== Ending test "RegistryItemNode returns placeholder node if no children are present" ===

=== Starting test "RegistryItemNode returns schemas that belong to Registry" ===
=== Ending test "RegistryItemNode returns schemas that belong to Registry" ===

=== Starting test "DefaultRegistryNode Sorts Registries" ===
=== Ending test "DefaultRegistryNode Sorts Registries" ===

=== Starting test "DefaultRegistryNode returns placeholder node if no children are present" ===
=== Ending test "DefaultRegistryNode returns placeholder node if no children are present" ===

=== Starting test "DefaultRegistryNode handles error" ===
Error while getting Child nodes: Hello there!
=== Ending test "DefaultRegistryNode handles error" ===

=== Starting test "SchemaItemNode initializes name and tooltip" ===
=== Ending test "SchemaItemNode initializes name and tooltip" ===

=== Starting test "SchemaItemNode initializes icon" ===
=== Ending test "SchemaItemNode initializes icon" ===

=== Starting test "SchemaItemNode returns expected context value" ===
=== Ending test "SchemaItemNode returns expected context value" ===

=== Starting test "SchemaItemNode has no children" ===
=== Ending test "SchemaItemNode has no children" ===

=== Starting test "RegistryItemNode Sorts Schema Items By Name" ===
=== Ending test "RegistryItemNode Sorts Schema Items By Name" ===

=== Starting test "RegistryItemNode handles error" ===
Error while getting Child nodes: Hello there!
=== Ending test "RegistryItemNode handles error" ===

=== Starting test "SchemasNode returns placeholder node if no children are present" ===
=== Ending test "SchemasNode returns placeholder node if no children are present" ===

=== Starting test "SchemasNode has RegistryItemNode child nodes" ===
=== Ending test "SchemasNode has RegistryItemNode child nodes" ===

=== Starting test "SchemasNode sorts child nodes" ===
=== Ending test "SchemasNode sorts child nodes" ===

=== Starting test "SchemasNode has an error node for a child if an error happens during loading" ===
Error while getting Child nodes: Update Children error!
=== Ending test "SchemasNode has an error node for a child if an error happens during loading" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "aws event" package name" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "aws event" package name" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "aws event" package name containing package seperator @" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "aws event" package name containing package seperator @" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "partner event" package name containing slash,numbers,dash and package seperator @" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "partner event" package name containing slash,numbers,dash and package seperator @" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "partner event" package name containing other special characters" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "partner event" package name containing other special characters" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "partner event" package name containing package seperator @ only" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "partner event" package name containing package seperator @ only" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing no special characters" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing no special characters" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing special characters" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing special characters" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing package seperator" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing package seperator" ===

=== Starting test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing multiple package seperators" ===
=== Ending test "SchemaCodeGenUtils buildSchemaPackageName builds the "custom event" package name containing multiple package seperators" ===

=== Starting test "IdentifierFormatter toValidIdentifier replaces invalid identifier characters with underscore" ===
=== Ending test "IdentifierFormatter toValidIdentifier replaces invalid identifier characters with underscore" ===

=== Starting test "IdentifierFormatter toValidIdentifier replaces package seperator @ with dot" ===
=== Ending test "IdentifierFormatter toValidIdentifier replaces package seperator @ with dot" ===

=== Starting test "getLanguageDetails should successfully return details for supported languages" ===
=== Ending test "getLanguageDetails should successfully return details for supported languages" ===

=== Starting test "getApiValueForSchemasDownload should return api value for runtimes supported by eventBridge application" ===
=== Ending test "getApiValueForSchemasDownload should return api value for runtimes supported by eventBridge application" ===

=== Starting test "schemasDataProvider getRegistries should return registries for given region" ===
=== Ending test "schemasDataProvider getRegistries should return registries for given region" ===

=== Starting test "schemasDataProvider getRegistries should retain results when it is queried with same credentials " ===
=== Ending test "schemasDataProvider getRegistries should retain results when it is queried with same credentials " ===

=== Starting test "schemasDataProvider getRegistries should retain results when it is queried with different credentials " ===
=== Ending test "schemasDataProvider getRegistries should retain results when it is queried with different credentials " ===

=== Starting test "schemasDataProvider getRegistries should return undefined when error occurs" ===
Error retrieving registries
TypeError: o[Symbol.iterator] is not a function
=== Ending test "schemasDataProvider getRegistries should return undefined when error occurs" ===

=== Starting test "schemasDataProvider getSchemas should return schemas for given region" ===
=== Ending test "schemasDataProvider getSchemas should return schemas for given region" ===

=== Starting test "schemasDataProvider getSchemas should retain results when it is queried with same credentials " ===
=== Ending test "schemasDataProvider getSchemas should retain results when it is queried with same credentials " ===

=== Starting test "schemasDataProvider getSchemas should retain results when it is queried with different credentials " ===
=== Ending test "schemasDataProvider getSchemas should retain results when it is queried with different credentials " ===

=== Starting test "schemasDataProvider getSchemas should return undefined when error occurs " ===
Error retrieving schemas
TypeError: o[Symbol.iterator] is not a function
=== Ending test "schemasDataProvider getSchemas should return undefined when error occurs " ===

=== Starting test "Build template parameters for AwsEventSchema should build correct template parameters for aws event schema" ===
=== Ending test "Build template parameters for AwsEventSchema should build correct template parameters for aws event schema" ===

=== Starting test "Build template parameters for PartnerSchema should build correct template parameters for partner schema" ===
=== Ending test "Build template parameters for PartnerSchema should build correct template parameters for partner schema" ===

=== Starting test "Build template parameters for CustomerUploadedSchema should build correct template parameters for customer uploaded schema with single type" ===
=== Ending test "Build template parameters for CustomerUploadedSchema should build correct template parameters for customer uploaded schema with single type" ===

=== Starting test "Build template parameters for CustomerUploadedSchemaMultipleTypes should  build correct template parameters for customer uploaded schema with multiple types" ===
=== Ending test "Build template parameters for CustomerUploadedSchemaMultipleTypes should  build correct template parameters for customer uploaded schema with multiple types" ===

=== Starting test "SchemaCodeDownloadWizard version uses user response as schemaVersion" ===
=== Ending test "SchemaCodeDownloadWizard version uses user response as schemaVersion" ===

=== Starting test "SchemaCodeDownloadWizard version exits when cancelled" ===
=== Ending test "SchemaCodeDownloadWizard version exits when cancelled" ===

=== Starting test "SchemaCodeDownloadWizard language uses user response as language" ===
=== Ending test "SchemaCodeDownloadWizard language uses user response as language" ===

=== Starting test "SchemaCodeDownloadWizard language backtracks when cancelled" ===
=== Ending test "SchemaCodeDownloadWizard language backtracks when cancelled" ===

=== Starting test "SchemaCodeDownloadWizard location uses user response as location" ===
=== Ending test "SchemaCodeDownloadWizard location uses user response as location" ===

=== Starting test "SchemaCodeDownloadWizard location backtracks when cancelled" ===
=== Ending test "SchemaCodeDownloadWizard location backtracks when cancelled" ===

=== Starting test "SchemaCodeDownloadWizard location contains a 'browse' option" ===
=== Ending test "SchemaCodeDownloadWizard location contains a 'browse' option" ===

=== Starting test "SchemaCodeDownloadWizard location contains an option for each workspace folder" ===
=== Ending test "SchemaCodeDownloadWizard location contains an option for each workspace folder" ===

=== Starting test "submitFeedbackListener submits feedback, disposes, and shows message on success" ===
Submitting Positive feedback
Successfully submitted Positive feedback
=== Ending test "submitFeedbackListener submits feedback, disposes, and shows message on success" ===

=== Starting test "submitFeedbackListener submits feedback and posts failure message on failure" ===
Submitting Positive feedback
Failed to submit Positive feedback: Expected failure
=== Ending test "submitFeedbackListener submits feedback and posts failure message on failure" ===

=== Starting test "deleteLambda should do nothing if function name is not provided" ===
=== Ending test "deleteLambda should do nothing if function name is not provided" ===

=== Starting test "deleteLambda should delete lambda when confirmed" ===
=== Ending test "deleteLambda should delete lambda when confirmed" ===

=== Starting test "deleteLambda should not delete lambda when cancelled" ===
=== Ending test "deleteLambda should not delete lambda when cancelled" ===

=== Starting test "deleteLambda should handles errors gracefully" ===
=== Ending test "deleteLambda should handles errors gracefully" ===

=== Starting test "deploySamApplication deploys with the happy path" ===
=== Ending test "deploySamApplication deploys with the happy path" ===

=== Starting test "deploySamApplication informs user of error when user is not logged in" ===
Error: No AWS profile selected
=== Ending test "deploySamApplication informs user of error when user is not logged in" ===

=== Starting test "deploySamApplication informs user of error when sam cli is invalid" ===
Error: SAM CLI was not found
=== Ending test "deploySamApplication informs user of error when sam cli is invalid" ===

=== Starting test "deploySamApplication exits if the wizard is cancelled" ===
=== Ending test "deploySamApplication exits if the wizard is cancelled" ===

=== Starting test "deploySamApplication informs user of error if invoking sam build fails" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: broken build
stderr: 
stdout: 
Error: Error with child process: broken build
=== Ending test "deploySamApplication informs user of error if invoking sam build fails" ===

=== Starting test "deploySamApplication informs user of error if invoking sam package fails" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: broken package
stderr: 
stdout: 
Error: Error with child process: broken package
=== Ending test "deploySamApplication informs user of error if invoking sam package fails" ===

=== Starting test "deploySamApplication informs user of error if invoking sam deploy fails" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: broken deploy
stderr: 
stdout: 
Error: Error with child process: broken deploy
Error: Deploy failed
=== Ending test "deploySamApplication informs user of error if invoking sam deploy fails" ===

=== Starting test "SamParameterCompletionItemProvider recovers gracefully if document is not in a workspace" ===
=== Ending test "SamParameterCompletionItemProvider recovers gracefully if document is not in a workspace" ===

=== Starting test "SamParameterCompletionItemProvider does not provide suggestions if document symbols could not be loaded" ===
=== Ending test "SamParameterCompletionItemProvider does not provide suggestions if document symbols could not be loaded" ===

=== Starting test "SamParameterCompletionItemProvider does not provide suggestions if no matching template is found" ===
=== Ending test "SamParameterCompletionItemProvider does not provide suggestions if no matching template is found" ===

=== Starting test "SamParameterCompletionItemProvider suggests all parameter names if user has not started typing the parameter name" ===
=== Ending test "SamParameterCompletionItemProvider suggests all parameter names if user has not started typing the parameter name" ===

=== Starting test "SamParameterCompletionItemProvider suggests only matching parameter names if user has started typing the parameter name" ===
=== Ending test "SamParameterCompletionItemProvider suggests only matching parameter names if user has started typing the parameter name" ===

=== Starting test "SamParameterCompletionItemProvider recovers gracefully if templates.json is empty or invalid" ===
=== Ending test "SamParameterCompletionItemProvider recovers gracefully if templates.json is empty or invalid" ===

=== Starting test "SamParameterCompletionItemProvider recovers gracefully if cursor is not within the `templates` property" ===
=== Ending test "SamParameterCompletionItemProvider recovers gracefully if cursor is not within the `templates` property" ===

=== Starting test "SamParameterCompletionItemProvider recovers gracefully if `parameterOverrides` is not defined for this template" ===
=== Ending test "SamParameterCompletionItemProvider recovers gracefully if `parameterOverrides` is not defined for this template" ===

=== Starting test "SamParameterCompletionItemProvider recovers gracefully if cursor is not within the `parameterOverrides` property" ===
=== Ending test "SamParameterCompletionItemProvider recovers gracefully if cursor is not within the `parameterOverrides` property" ===

=== Starting test "SamParameterCompletionItemProvider recovers gracefully if cursor is not within a property name within `parameterOverrides`" ===
=== Ending test "SamParameterCompletionItemProvider recovers gracefully if cursor is not within a property name within `parameterOverrides`" ===

=== Starting test "templates load loads a valid file without parameter overrides" ===
=== Ending test "templates load loads a valid file without parameter overrides" ===

=== Starting test "templates load loads a valid file with parameter overrides" ===
=== Ending test "templates load loads a valid file with parameter overrides" ===

=== Starting test "templates load returns minimal config on missing file" ===
=== Ending test "templates load returns minimal config on missing file" ===

=== Starting test "templates load throws on error loading file" ===
=== Ending test "templates load throws on error loading file" ===

=== Starting test "templates load gracefully handles invalid JSON" ===
=== Ending test "templates load gracefully handles invalid JSON" ===

=== Starting test "templates load supports JSON comments" ===
=== Ending test "templates load supports JSON comments" ===

=== Starting test "templates load reads the correct path" ===
=== Ending test "templates load reads the correct path" ===

=== Starting test "templates load saves dirty documents before loading" ===
=== Ending test "templates load saves dirty documents before loading" ===

=== Starting test "getTemplatesConfigPath returns expected path" ===
=== Ending test "getTemplatesConfigPath returns expected path" ===

=== Starting test "TemplatesConfigPopulator handles ModificationOptions" ===
=== Ending test "TemplatesConfigPopulator handles ModificationOptions" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateSectionExists handles clean data" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateSectionExists handles clean data" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateSectionExists handles missing templates section" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateSectionExists handles missing templates section" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateSectionExists handles missing template section" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateSectionExists handles missing template section" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateSectionExists errs with invalid templates type" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateSectionExists errs with invalid templates type" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists handles clean data" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists handles clean data" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists errs with invalid template type" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists errs with invalid template type" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists errs with invalid handlers type" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists errs with invalid handlers type" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists errs with invalid handler type" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists errs with invalid handler type" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists handles missing handlers section" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists handles missing handlers section" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists handles missing handler section" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerSectionExists handles missing handler section" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles clean data" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles clean data" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist errs with invalid handler type" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist errs with invalid handler type" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist errs with invalid event type" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist errs with invalid event type" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles missing everything" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles missing everything" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles missing event" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles missing event" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles missing envvars" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateHandlerPropertiesExist handles missing envvars" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists creates parameterOverrides section if it does not already exist" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists creates parameterOverrides section if it does not already exist" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists adds new override if it does not already exist" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists adds new override if it does not already exist" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists does not overwrite existing overrides" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists does not overwrite existing overrides" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists throws if parameterOverrides exists, but is not an object or null" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists throws if parameterOverrides exists, but is not an object or null" ===

=== Starting test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists throws if override value exists, but is not a string or null" ===
=== Ending test "TemplatesConfigPopulator ensureTemplateParameterOverrideExists throws if override value exists, but is not a string or null" ===

=== Starting test "CloudFormationStackNode initializes name and tooltip" ===
=== Ending test "CloudFormationStackNode initializes name and tooltip" ===

=== Starting test "CloudFormationStackNode initializes icon" ===
=== Ending test "CloudFormationStackNode initializes icon" ===

=== Starting test "CloudFormationStackNode returns placeholder node if no children are present" ===
=== Ending test "CloudFormationStackNode returns placeholder node if no children are present" ===

=== Starting test "CloudFormationStackNode has LambdaFunctionNode child nodes" ===
=== Ending test "CloudFormationStackNode has LambdaFunctionNode child nodes" ===

=== Starting test "CloudFormationStackNode has child nodes with CloudFormation contextValue" ===
=== Ending test "CloudFormationStackNode has child nodes with CloudFormation contextValue" ===

=== Starting test "CloudFormationStackNode only includes functions which are in a CloudFormation stack" ===
=== Ending test "CloudFormationStackNode only includes functions which are in a CloudFormation stack" ===

=== Starting test "CloudFormationStackNode sorts child nodes" ===
=== Ending test "CloudFormationStackNode sorts child nodes" ===

=== Starting test "CloudFormationStackNode has an error node for a child if an error happens during loading" ===
Error while getting Child nodes: loading failure
=== Ending test "CloudFormationStackNode has an error node for a child if an error happens during loading" ===

=== Starting test "CloudFormationNode has CloudFormationStackNode child nodes" ===
=== Ending test "CloudFormationNode has CloudFormationStackNode child nodes" ===

=== Starting test "CloudFormationNode has sorted child nodes" ===
=== Ending test "CloudFormationNode has sorted child nodes" ===

=== Starting test "CloudFormationNode returns placeholder node if no children are present" ===
=== Ending test "CloudFormationNode returns placeholder node if no children are present" ===

=== Starting test "CloudFormationNode has an error node for a child if an error happens during loading" ===
Error while getting Child nodes: Update Children error!
=== Ending test "CloudFormationNode has an error node for a child if an error happens during loading" ===

=== Starting test "LambdaFunctionNode instantiates without issue" ===
=== Ending test "LambdaFunctionNode instantiates without issue" ===

=== Starting test "LambdaFunctionNode initializes the parent node" ===
=== Ending test "LambdaFunctionNode initializes the parent node" ===

=== Starting test "LambdaFunctionNode initializes the region code" ===
=== Ending test "LambdaFunctionNode initializes the region code" ===

=== Starting test "LambdaFunctionNode initializes the label" ===
=== Ending test "LambdaFunctionNode initializes the label" ===

=== Starting test "LambdaFunctionNode initializes the functionName" ===
=== Ending test "LambdaFunctionNode initializes the functionName" ===

=== Starting test "LambdaFunctionNode initializes the tooltip" ===
=== Ending test "LambdaFunctionNode initializes the tooltip" ===

=== Starting test "LambdaFunctionNode initializes the icon" ===
=== Ending test "LambdaFunctionNode initializes the icon" ===

=== Starting test "LambdaFunctionNode has no children" ===
=== Ending test "LambdaFunctionNode has no children" ===

=== Starting test "LambdaNode returns placeholder node if no children are present" ===
=== Ending test "LambdaNode returns placeholder node if no children are present" ===

=== Starting test "LambdaNode has LambdaFunctionNode child nodes" ===
=== Ending test "LambdaNode has LambdaFunctionNode child nodes" ===

=== Starting test "LambdaNode has child nodes with Lambda Function contextValue" ===
=== Ending test "LambdaNode has child nodes with Lambda Function contextValue" ===

=== Starting test "LambdaNode sorts child nodes" ===
=== Ending test "LambdaNode sorts child nodes" ===

=== Starting test "LambdaNode has an error node for a child if an error happens during loading" ===
Error while getting Child nodes: Update Children error!
=== Ending test "LambdaNode has an error node for a child if an error happens during loading" ===

=== Starting test "makeCoreCLRDebugConfiguration uses the specified codeUri" ===
=== Ending test "makeCoreCLRDebugConfiguration uses the specified codeUri" ===

=== Starting test "makeCoreCLRDebugConfiguration windows uses powershell" ===
=== Ending test "makeCoreCLRDebugConfiguration windows uses powershell" ===

=== Starting test "makeCoreCLRDebugConfiguration windows uses the specified port" ===
=== Ending test "makeCoreCLRDebugConfiguration windows uses the specified port" ===

=== Starting test "makeCoreCLRDebugConfiguration *nix uses the default shell" ===
=== Ending test "makeCoreCLRDebugConfiguration *nix uses the default shell" ===

=== Starting test "makeCoreCLRDebugConfiguration *nix uses the specified port" ===
=== Ending test "makeCoreCLRDebugConfiguration *nix uses the specified port" ===

=== Starting test "detectLocalLambdas detects no lambdas when workspaceFolders is empty" ===
=== Ending test "detectLocalLambdas detects no lambdas when workspaceFolders is empty" ===

=== Starting test "detectLocalLambdas detects no lambdas when template.y[a]ml does not exist" ===
=== Ending test "detectLocalLambdas detects no lambdas when template.y[a]ml does not exist" ===

=== Starting test "detectLocalLambdas detects no lambdas when template.y[a]ml is empty" ===
=== Ending test "detectLocalLambdas detects no lambdas when template.y[a]ml is empty" ===

=== Starting test "detectLocalLambdas detects lambdas when template.yml exists" ===
=== Ending test "detectLocalLambdas detects lambdas when template.yml exists" ===

=== Starting test "detectLocalLambdas detects lambdas when template.yaml exists" ===
=== Ending test "detectLocalLambdas detects lambdas when template.yaml exists" ===

=== Starting test "detectLocalLambdas detects lambdas in multi-folder workspace" ===
=== Ending test "detectLocalLambdas detects lambdas in multi-folder workspace" ===

=== Starting test "detectLocalTemplates Detects no templates when there are no workspace folders" ===
=== Ending test "detectLocalTemplates Detects no templates when there are no workspace folders" ===

=== Starting test "detectLocalTemplates Detects templates at the root of each workspace folder" ===
=== Ending test "detectLocalTemplates Detects templates at the root of each workspace folder" ===

=== Starting test "detectLocalTemplates Detects templates in child folders of each workspace folder" ===
=== Ending test "detectLocalTemplates Detects templates in child folders of each workspace folder" ===

=== Starting test "detectLocalTemplates does not detect templates deeper than the specified folder depth" ===
=== Ending test "detectLocalTemplates does not detect templates deeper than the specified folder depth" ===

=== Starting test "detectLocalTemplates Detects multiple templates when multiple folders contain templates" ===
=== Ending test "detectLocalTemplates Detects multiple templates when multiple folders contain templates" ===

=== Starting test "detectLocalTemplates Detects multiple templates when both template.yml and template.yaml exist in a folder" ===
=== Ending test "detectLocalTemplates Detects multiple templates when both template.yml and template.yaml exist in a folder" ===

=== Starting test "compareSamLambdaRuntime nodejs8.10 < nodejs10.x" ===
=== Ending test "compareSamLambdaRuntime nodejs8.10 < nodejs10.x" ===

=== Starting test "compareSamLambdaRuntime nodejs10.x > nodejs8.10" ===
=== Ending test "compareSamLambdaRuntime nodejs10.x > nodejs8.10" ===

=== Starting test "compareSamLambdaRuntime nodejs8.10 < nodejs12.x" ===
=== Ending test "compareSamLambdaRuntime nodejs8.10 < nodejs12.x" ===

=== Starting test "compareSamLambdaRuntime nodejs12.x > nodejs8.10" ===
=== Ending test "compareSamLambdaRuntime nodejs12.x > nodejs8.10" ===

=== Starting test "compareSamLambdaRuntime nodejs10.x < nodejs12.x" ===
=== Ending test "compareSamLambdaRuntime nodejs10.x < nodejs12.x" ===

=== Starting test "compareSamLambdaRuntime nodejs12.x > nodejs10.x" ===
=== Ending test "compareSamLambdaRuntime nodejs12.x > nodejs10.x" ===

=== Starting test "getDependencyManager all runtimes are handled" ===
=== Ending test "getDependencyManager all runtimes are handled" ===

=== Starting test "getFamily all runtimes are handled" ===
=== Ending test "getFamily all runtimes are handled" ===

=== Starting test "getSamTemplateWizardOption should successfully return available templates for specific runtime" ===
=== Ending test "getSamTemplateWizardOption should successfully return available templates for specific runtime" ===

=== Starting test "getSamCliTemplateParameter should successfully return template values used by sam cli" ===
=== Ending test "getSamCliTemplateParameter should successfully return template values used by sam cli" ===

=== Starting test "getSamCliTemplateParameter should return error if the template option is not valid" ===
=== Ending test "getSamCliTemplateParameter should return error if the template option is not valid" ===

=== Starting test "getTemplateDescription all templates are handled" ===
=== Ending test "getTemplateDescription all templates are handled" ===

=== Starting test "parameterUtils getParameters returns an empty map if template has no parameters section" ===
=== Ending test "parameterUtils getParameters returns an empty map if template has no parameters section" ===

=== Starting test "parameterUtils getParameters returns an empty map if parameters section is empty" ===
=== Ending test "parameterUtils getParameters returns an empty map if parameters section is empty" ===

=== Starting test "parameterUtils getParameters sets `required` to true if default is undefined" ===
=== Ending test "parameterUtils getParameters sets `required` to true if default is undefined" ===

=== Starting test "parameterUtils getParameters sets `required` to false if default is defined, but falsy" ===
=== Ending test "parameterUtils getParameters sets `required` to false if default is defined, but falsy" ===

=== Starting test "parameterUtils getParameters sets `required` to false if default is defined and truthy" ===
=== Ending test "parameterUtils getParameters sets `required` to false if default is defined and truthy" ===

=== Starting test "parameterUtils getParameterNames returns an empty array if no parameters were found" ===
=== Ending test "parameterUtils getParameterNames returns an empty array if no parameters were found" ===

=== Starting test "parameterUtils getParameterNames returns the names of each parameter" ===
=== Ending test "parameterUtils getParameterNames returns the names of each parameter" ===

=== Starting test "parameterUtils getOverriddenParameters throws if template is not in the workspace" ===
=== Ending test "parameterUtils getOverriddenParameters throws if template is not in the workspace" ===

=== Starting test "parameterUtils getOverriddenParameters returns undefined if no config is found for this template" ===
=== Ending test "parameterUtils getOverriddenParameters returns undefined if no config is found for this template" ===

=== Starting test "parameterUtils getOverriddenParameters returns undefined if config for this template does not contain `parameterOverrides`" ===
=== Ending test "parameterUtils getOverriddenParameters returns undefined if config for this template does not contain `parameterOverrides`" ===

=== Starting test "parameterUtils getOverriddenParameters returns an empty map if this template contains an empty `parameterOverrides`" ===
=== Ending test "parameterUtils getOverriddenParameters returns an empty map if this template contains an empty `parameterOverrides`" ===

=== Starting test "parameterUtils getOverriddenParameters returns a map of parameter names to their overridden values" ===
=== Ending test "parameterUtils getOverriddenParameters returns a map of parameter names to their overridden values" ===

=== Starting test "SamDeployWizard TEMPLATE fails gracefully when no templates are found" ===
=== Ending test "SamDeployWizard TEMPLATE fails gracefully when no templates are found" ===

=== Starting test "SamDeployWizard TEMPLATE exits wizard when cancelled" ===
=== Ending test "SamDeployWizard TEMPLATE exits wizard when cancelled" ===

=== Starting test "SamDeployWizard TEMPLATE uses user response as template" ===
=== Ending test "SamDeployWizard TEMPLATE uses user response as template" ===

=== Starting test "SamDeployWizard PARAMETER_OVERRIDES SAM template has no parameters skips configuring overrides and continues wizard" ===
=== Ending test "SamDeployWizard PARAMETER_OVERRIDES SAM template has no parameters skips configuring overrides and continues wizard" ===

=== Starting test "SamDeployWizard PARAMETER_OVERRIDES SAM template has only optional parameters skips configuring overrides and continues wizard if parameterOverrides is defined" ===
=== Ending test "SamDeployWizard PARAMETER_OVERRIDES SAM template has only optional parameters skips configuring overrides and continues wizard if parameterOverrides is defined" ===

=== Starting test "SamDeployWizard PARAMETER_OVERRIDES SAM template has only optional parameters skips configuring overrides and continues wizard if parameterOverrides is undefined and user declines prompt" ===
=== Ending test "SamDeployWizard PARAMETER_OVERRIDES SAM template has only optional parameters skips configuring overrides and continues wizard if parameterOverrides is undefined and user declines prompt" ===

=== Starting test "SamDeployWizard PARAMETER_OVERRIDES SAM template has only optional parameters configures overrides and cancels wizard if parameterOverrides is undefined and user accepts prompt" ===
=== Ending test "SamDeployWizard PARAMETER_OVERRIDES SAM template has only optional parameters configures overrides and cancels wizard if parameterOverrides is undefined and user accepts prompt" ===

=== Starting test "SamDeployWizard PARAMETER_OVERRIDES SAM template has required parameters configures overrides and cancels wizard if overrides are not defined" ===
=== Ending test "SamDeployWizard PARAMETER_OVERRIDES SAM template has required parameters configures overrides and cancels wizard if overrides are not defined" ===

=== Starting test "SamDeployWizard PARAMETER_OVERRIDES SAM template has required parameters configures overrides and cancels wizard if there are missing overrides" ===
=== Ending test "SamDeployWizard PARAMETER_OVERRIDES SAM template has required parameters configures overrides and cancels wizard if there are missing overrides" ===

=== Starting test "SamDeployWizard PARAMETER_OVERRIDES SAM template has required parameters stores existing overrides and continues without configuring overrides if there are no missing overrides" ===
=== Ending test "SamDeployWizard PARAMETER_OVERRIDES SAM template has required parameters stores existing overrides and continues without configuring overrides if there are no missing overrides" ===

=== Starting test "SamDeployWizard REGION uses user response for region" ===
=== Ending test "SamDeployWizard REGION uses user response for region" ===

=== Starting test "SamDeployWizard REGION goes back when cancelled" ===
=== Ending test "SamDeployWizard REGION goes back when cancelled" ===

=== Starting test "SamDeployWizard S3_BUCKET goes back when cancelled" ===
=== Ending test "SamDeployWizard S3_BUCKET goes back when cancelled" ===

=== Starting test "SamDeployWizard S3_BUCKET uses user response as s3Bucket" ===
=== Ending test "SamDeployWizard S3_BUCKET uses user response as s3Bucket" ===

=== Starting test "SamDeployWizard STACK_NAME goes back when cancelled" ===
=== Ending test "SamDeployWizard STACK_NAME goes back when cancelled" ===

=== Starting test "SamDeployWizard STACK_NAME uses user response as stackName" ===
=== Ending test "SamDeployWizard STACK_NAME uses user response as stackName" ===

=== Starting test "SamDeployWizard STACK_NAME validation validates that stackName does not contain invalid charcters" ===
=== Ending test "SamDeployWizard STACK_NAME validation validates that stackName does not contain invalid charcters" ===

=== Starting test "SamDeployWizard STACK_NAME validation validates that stackName begins with an alphabetic character" ===
=== Ending test "SamDeployWizard STACK_NAME validation validates that stackName begins with an alphabetic character" ===

=== Starting test "SamDeployWizard STACK_NAME validation validates that stackName is not longer than 128 characters" ===
=== Ending test "SamDeployWizard STACK_NAME validation validates that stackName is not longer than 128 characters" ===

=== Starting test "validateS3Bucket validates a valid bucket name" ===
=== Ending test "validateS3Bucket validates a valid bucket name" ===

=== Starting test "validateS3Bucket validates that bucket name has a valid length" ===
=== Ending test "validateS3Bucket validates that bucket name has a valid length" ===

=== Starting test "validateS3Bucket validates that bucket name does not contain invalid characters" ===
=== Ending test "validateS3Bucket validates that bucket name does not contain invalid characters" ===

=== Starting test "validateS3Bucket validates that bucket name is not formatted as an ip address" ===
=== Ending test "validateS3Bucket validates that bucket name is not formatted as an ip address" ===

=== Starting test "validateS3Bucket validates that bucket name does not end with a dash" ===
=== Ending test "validateS3Bucket validates that bucket name does not end with a dash" ===

=== Starting test "validateS3Bucket validates that bucket name does not contain consecutive periods" ===
=== Ending test "validateS3Bucket validates that bucket name does not contain consecutive periods" ===

=== Starting test "validateS3Bucket validates that bucket name does not contain a period adjacent to a dash" ===
=== Ending test "validateS3Bucket validates that bucket name does not contain a period adjacent to a dash" ===

=== Starting test "validateS3Bucket validates that each label in bucket name begins with a number or a lower-case character" ===
=== Ending test "validateS3Bucket validates that each label in bucket name begins with a number or a lower-case character" ===

=== Starting test "CreateNewSamAppWizard runtime uses user response as runtime" ===
=== Ending test "CreateNewSamAppWizard runtime uses user response as runtime" ===

=== Starting test "CreateNewSamAppWizard runtime exits when cancelled" ===
=== Ending test "CreateNewSamAppWizard runtime exits when cancelled" ===

=== Starting test "CreateNewSamAppWizard template uses user response as template" ===
=== Ending test "CreateNewSamAppWizard template uses user response as template" ===

=== Starting test "CreateNewSamAppWizard template backtracks when cancelled" ===
=== Ending test "CreateNewSamAppWizard template backtracks when cancelled" ===

=== Starting test "CreateNewSamAppWizard location uses user response as location" ===
=== Ending test "CreateNewSamAppWizard location uses user response as location" ===

=== Starting test "CreateNewSamAppWizard location backtracks when cancelled" ===
=== Ending test "CreateNewSamAppWizard location backtracks when cancelled" ===

=== Starting test "CreateNewSamAppWizard location contains a 'browse' option" ===
=== Ending test "CreateNewSamAppWizard location contains a 'browse' option" ===

=== Starting test "CreateNewSamAppWizard location contains an option for each workspace folder" ===
=== Ending test "CreateNewSamAppWizard location contains an option for each workspace folder" ===

=== Starting test "CreateNewSamAppWizard name uses user response as name" ===
=== Ending test "CreateNewSamAppWizard name uses user response as name" ===

=== Starting test "CreateNewSamAppWizard name backtracks when cancelled" ===
=== Ending test "CreateNewSamAppWizard name backtracks when cancelled" ===

=== Starting test "ActivationLaunchPath setLaunchPath" ===
=== Ending test "ActivationLaunchPath setLaunchPath" ===

=== Starting test "ActivationLaunchPath getLaunchPath" ===
=== Ending test "ActivationLaunchPath getLaunchPath" ===

=== Starting test "ActivationLaunchPath clearLaunchPath" ===
=== Ending test "ActivationLaunchPath clearLaunchPath" ===

=== Starting test "defaultEcsClient listClusters lists clusters from a single page" ===
=== Ending test "defaultEcsClient listClusters lists clusters from a single page" ===

=== Starting test "defaultEcsClient listClusters lists clusters from multiple pages" ===
=== Ending test "defaultEcsClient listClusters lists clusters from multiple pages" ===

=== Starting test "defaultEcsClient listClusters handles errors" ===
=== Ending test "defaultEcsClient listClusters handles errors" ===

=== Starting test "defaultEcsClient listServices lists services from a single page" ===
=== Ending test "defaultEcsClient listServices lists services from a single page" ===

=== Starting test "defaultEcsClient listServices lists services from multiple pages" ===
=== Ending test "defaultEcsClient listServices lists services from multiple pages" ===

=== Starting test "defaultEcsClient listServices handles errors" ===
=== Ending test "defaultEcsClient listServices handles errors" ===

=== Starting test "defaultEcsClient ListTaskDefinitionFamilies lists task definition families from a single page" ===
=== Ending test "defaultEcsClient ListTaskDefinitionFamilies lists task definition families from a single page" ===

=== Starting test "defaultEcsClient ListTaskDefinitionFamilies lists task definition families from multiple pages" ===
=== Ending test "defaultEcsClient ListTaskDefinitionFamilies lists task definition families from multiple pages" ===

=== Starting test "defaultEcsClient ListTaskDefinitionFamilies handles errors" ===
=== Ending test "defaultEcsClient ListTaskDefinitionFamilies handles errors" ===

=== Starting test "DefaultDockerClient invoke uses the specified command" ===
=== Ending test "DefaultDockerClient invoke uses the specified command" ===

=== Starting test "DefaultDockerClient invoke uses the specified image" ===
=== Ending test "DefaultDockerClient invoke uses the specified image" ===

=== Starting test "DefaultDockerClient invoke includes the --rm flag if specified" ===
=== Ending test "DefaultDockerClient invoke includes the --rm flag if specified" ===

=== Starting test "DefaultDockerClient invoke includes the --mount flag if specified" ===
=== Ending test "DefaultDockerClient invoke includes the --mount flag if specified" ===

=== Starting test "DefaultDockerClient invoke includes the --entryPoint flag if specified" ===
=== Ending test "DefaultDockerClient invoke includes the --entryPoint flag if specified" ===

=== Starting test "CloudFormation load can successfully load a file" ===
=== Ending test "CloudFormation load can successfully load a file" ===

=== Starting test "CloudFormation load can successfully load a file without globals" ===
=== Ending test "CloudFormation load can successfully load a file without globals" ===

=== Starting test "CloudFormation load can successfully load a file with parameters" ===
=== Ending test "CloudFormation load can successfully load a file with parameters" ===

=== Starting test "CloudFormation load Does not load YAML with missing fields" ===
=== Ending test "CloudFormation load Does not load YAML with missing fields" ===

=== Starting test "CloudFormation load only loads valid YAML" ===
=== Ending test "CloudFormation load only loads valid YAML" ===

=== Starting test "CloudFormation load Loads YAML with references" ===
=== Ending test "CloudFormation load Loads YAML with references" ===

=== Starting test "CloudFormation save can successfully save a file" ===
=== Ending test "CloudFormation save can successfully save a file" ===

=== Starting test "CloudFormation save can successfully save a file to YAML and load the file as a CloudFormation.Template" ===
=== Ending test "CloudFormation save can successfully save a file to YAML and load the file as a CloudFormation.Template" ===

=== Starting test "CloudFormation validateTemplate can successfully validate a valid template" ===
=== Ending test "CloudFormation validateTemplate can successfully validate a valid template" ===

=== Starting test "CloudFormation validateTemplate can detect an invalid template" ===
=== Ending test "CloudFormation validateTemplate can detect an invalid template" ===

=== Starting test "CloudFormation validateResource can successfully validate a valid resource" ===
=== Ending test "CloudFormation validateResource can successfully validate a valid resource" ===

=== Starting test "CloudFormation validateResource can detect an invalid resource" ===
=== Ending test "CloudFormation validateResource can detect an invalid resource" ===

=== Starting test "CloudFormation getResourceFromTemplate should retrieve resource for existing lambda, single runtime" ===
=== Ending test "CloudFormation getResourceFromTemplate should retrieve resource for existing lambda, single runtime" ===

=== Starting test "CloudFormation getResourceFromTemplate should retrieve resource for 2nd existing lambda, multiple runtimes" ===
=== Ending test "CloudFormation getResourceFromTemplate should retrieve resource for 2nd existing lambda, multiple runtimes" ===

=== Starting test "CloudFormation getResourceFromTemplate should retrieve resource for 1st existing lambda, multiple runtimes" ===
=== Ending test "CloudFormation getResourceFromTemplate should retrieve resource for 1st existing lambda, multiple runtimes" ===

=== Starting test "CloudFormation getResourceFromTemplate should throw for non-existing lambda, single runtime" ===
=== Ending test "CloudFormation getResourceFromTemplate should throw for non-existing lambda, single runtime" ===

=== Starting test "CloudFormation getResourceFromTemplate should throw for non-existing lambda, multiple runtimes" ===
=== Ending test "CloudFormation getResourceFromTemplate should throw for non-existing lambda, multiple runtimes" ===

=== Starting test "CloudFormation getResourceFromTemplateResources should retrieve resource for existing lambda, single runtime" ===
=== Ending test "CloudFormation getResourceFromTemplateResources should retrieve resource for existing lambda, single runtime" ===

=== Starting test "CloudFormation getResourceFromTemplateResources should retrieve resource for 2nd existing lambda, multiple runtimes" ===
=== Ending test "CloudFormation getResourceFromTemplateResources should retrieve resource for 2nd existing lambda, multiple runtimes" ===

=== Starting test "CloudFormation getResourceFromTemplateResources should retrieve resource for 1st existing lambda, multiple runtimes" ===
=== Ending test "CloudFormation getResourceFromTemplateResources should retrieve resource for 1st existing lambda, multiple runtimes" ===

=== Starting test "CloudFormation getResourceFromTemplateResources should throw for non-existing lambda, single runtime" ===
=== Ending test "CloudFormation getResourceFromTemplateResources should throw for non-existing lambda, single runtime" ===

=== Starting test "CloudFormation getResourceFromTemplateResources should throw for non-existing lambda, multiple runtimes" ===
=== Ending test "CloudFormation getResourceFromTemplateResources should throw for non-existing lambda, multiple runtimes" ===

=== Starting test "CloudFormation getRuntime throws if resource does not specify properties" ===
=== Ending test "CloudFormation getRuntime throws if resource does not specify properties" ===

=== Starting test "CloudFormation getRuntime throws if resource does not specify a runtime" ===
=== Ending test "CloudFormation getRuntime throws if resource does not specify a runtime" ===

=== Starting test "CloudFormation getRuntime returns runtime if specified" ===
=== Ending test "CloudFormation getRuntime returns runtime if specified" ===

=== Starting test "CloudFormation getCodeUri throws if resource does not specify properties" ===
=== Ending test "CloudFormation getCodeUri throws if resource does not specify properties" ===

=== Starting test "CloudFormation getCodeUri throws if resource does not specify a code uri" ===
=== Ending test "CloudFormation getCodeUri throws if resource does not specify a code uri" ===

=== Starting test "CloudFormation getCodeUri returns code uri if specified" ===
=== Ending test "CloudFormation getCodeUri returns code uri if specified" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplateToRegistry adds data from a template to the registry and can receive the template's data" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplateToRegistry adds data from a template to the registry and can receive the template's data" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplateToRegistry throws an error if the file to add is not a CF template" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplateToRegistry throws an error if the file to add is not a CF template" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplatesToRegistry adds data from multiple templates to the registry and can receive the templates' data" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplatesToRegistry adds data from multiple templates to the registry and can receive the templates' data" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplatesToRegistry swallows errors if a template is not parseable while still parsing valid YAML" ===
Template file:///tmp/aws-toolkit-vscode/vsctkQOuwg7/template2.yaml is malformed: end of the stream or a document separator is expected at line 1, column 6:
    {ASD}ASD{asd}ASD:asd
         ^
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry addTemplatesToRegistry swallows errors if a template is not parseable while still parsing valid YAML" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry registeredTemplates returns an empty array if the registry has no registered templates" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry registeredTemplates returns an empty array if the registry has no registered templates" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry getRegisteredTemplate returns undefined if the registry has no registered templates" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry getRegisteredTemplate returns undefined if the registry has no registered templates" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry getRegisteredTemplate returns undefined if the registry does not contain the template in question" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry getRegisteredTemplate returns undefined if the registry does not contain the template in question" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry removeTemplateFromRegistry removes an added template" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry removeTemplateFromRegistry removes an added template" ===

=== Starting test "CloudFormation Template Registry CloudFormationTemplateRegistry removeTemplateFromRegistry does not affect the registry if a nonexistant template is removed" ===
=== Ending test "CloudFormation Template Registry CloudFormationTemplateRegistry removeTemplateFromRegistry does not affect the registry if a nonexistant template is removed" ===

=== Starting test "findParentProjectFile locates project in same folder" ===
=== Ending test "findParentProjectFile locates project in same folder" ===

=== Starting test "findParentProjectFile locates project in parent folder" ===
=== Ending test "findParentProjectFile locates project in parent folder" ===

=== Starting test "findParentProjectFile locates project two parent folders up" ===
=== Ending test "findParentProjectFile locates project two parent folders up" ===

=== Starting test "findParentProjectFile selects project in same folder over parent folder" ===
=== Ending test "findParentProjectFile selects project in same folder over parent folder" ===

=== Starting test "findParentProjectFile returns undefined when no project files are located" ===
=== Ending test "findParentProjectFile returns undefined when no project files are located" ===

=== Starting test "findParentProjectFile returns undefined when no project files are located in parent chain" ===
=== Ending test "findParentProjectFile returns undefined when no project files are located in parent chain" ===

=== Starting test "getLambdaHandlerComponents Detects a public function symbol" ===
=== Ending test "getLambdaHandlerComponents Detects a public function symbol" ===

=== Starting test "isPublicClassSymbol returns true for a public class" ===
=== Ending test "isPublicClassSymbol returns true for a public class" ===

=== Starting test "isPublicClassSymbol returns false when symbol is not of type Class" ===
=== Ending test "isPublicClassSymbol returns false when symbol is not of type Class" ===

=== Starting test "isPublicClassSymbol returns false when class is not public" ===
=== Ending test "isPublicClassSymbol returns false when class is not public" ===

=== Starting test "isPublicMethodSymbol returns true for a public method symbol when signature all on one line" ===
=== Ending test "isPublicMethodSymbol returns true for a public method symbol when signature all on one line" ===

=== Starting test "isPublicMethodSymbol returns true for a public method symbol when signature across many lines" ===
=== Ending test "isPublicMethodSymbol returns true for a public method symbol when signature across many lines" ===

=== Starting test "isPublicMethodSymbol returns true for a public method symbol when method name on another line" ===
=== Ending test "isPublicMethodSymbol returns true for a public method symbol when method name on another line" ===

=== Starting test "isPublicMethodSymbol returns true for a public method symbol when args on many lines" ===
=== Ending test "isPublicMethodSymbol returns true for a public method symbol when args on many lines" ===

=== Starting test "isPublicMethodSymbol returns false for a symbol that is not a method" ===
=== Ending test "isPublicMethodSymbol returns false for a symbol that is not a method" ===

=== Starting test "isPublicMethodSymbol returns false when the method is not public" ===
=== Ending test "isPublicMethodSymbol returns false when the method is not public" ===

=== Starting test "isPublicMethodSymbol returns false when a private method name contains the word public in it" ===
=== Ending test "isPublicMethodSymbol returns false when a private method name contains the word public in it" ===

=== Starting test "generateDotNetLambdaHandler produces a handler name" ===
=== Ending test "generateDotNetLambdaHandler produces a handler name" ===

=== Starting test "localLambdaRunner attachDebugger Successful attach has no retries" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Successful attach has no retries" ===

=== Starting test "localLambdaRunner attachDebugger Successful attach logs that the debugger attached" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Successful attach logs that the debugger attached" ===

=== Starting test "localLambdaRunner attachDebugger Successful attach records a success metric" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Successful attach records a success metric" ===

=== Starting test "localLambdaRunner attachDebugger Successful attach returns success" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Successful attach returns success" ===

=== Starting test "localLambdaRunner attachDebugger Failure to attach has no retries" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Failure to attach has no retries" ===

=== Starting test "localLambdaRunner attachDebugger Failure to attach logs that the debugger did not attach" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Failure to attach logs that the debugger did not attach" ===

=== Starting test "localLambdaRunner attachDebugger Failure to attach records a fail metric" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Failure to attach records a fail metric" ===

=== Starting test "localLambdaRunner attachDebugger Failure to attach returns failure" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Failure to attach returns failure" ===

=== Starting test "localLambdaRunner attachDebugger Attempts to retry when startDebugging returns undefined" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Attempts to retry when startDebugging returns undefined" ===

=== Starting test "localLambdaRunner attachDebugger Logs about exceeding the retry limit" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Logs about exceeding the retry limit" ===

=== Starting test "localLambdaRunner attachDebugger Does not log metrics when startDebugging returns undefined" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Does not log metrics when startDebugging returns undefined" ===

=== Starting test "localLambdaRunner attachDebugger Returns true if attach succeeds during retries" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Returns true if attach succeeds during retries" ===

=== Starting test "localLambdaRunner attachDebugger Returns false if attach fails during retries" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Returns false if attach fails during retries" ===

=== Starting test "localLambdaRunner attachDebugger Returns false if retry count exceeded" ===
localLambdaRunner.attachDebugger: startDebugging with debugConfig: {}
=== Ending test "localLambdaRunner attachDebugger Returns false if retry count exceeded" ===

=== Starting test "localLambdaRunner makeBuildDir creates a temp directory" ===
=== Ending test "localLambdaRunner makeBuildDir creates a temp directory" ===

=== Starting test "localLambdaRunner executeSamBuild fails when the child process returns a nonzero exit code" ===
Unexpected exitcode (1), expecting (0)
Error: Error: you are already dead
stderr: big ugly failure message
stdout: friendly failure message
=== Ending test "localLambdaRunner executeSamBuild fails when the child process returns a nonzero exit code" ===

=== Starting test "localLambdaRunner executeSamBuild succeeds when the child process returns with an exit code of 0" ===
=== Ending test "localLambdaRunner executeSamBuild succeeds when the child process returns with an exit code of 0" ===

=== Starting test "getLocalRootVariants Returns the same string for non-windows platforms: Looks like a windows path - lower case drive" ===
=== Ending test "getLocalRootVariants Returns the same string for non-windows platforms: Looks like a windows path - lower case drive" ===

=== Starting test "getLocalRootVariants Returns the same string for non-windows platforms: Looks like a windows path - upper case drive" ===
=== Ending test "getLocalRootVariants Returns the same string for non-windows platforms: Looks like a windows path - upper case drive" ===

=== Starting test "getLocalRootVariants Returns the same string for non-windows platforms: non-windows path" ===
=== Ending test "getLocalRootVariants Returns the same string for non-windows platforms: non-windows path" ===

=== Starting test "getAccountId returns an account id (happy path)" ===
Getting AccountId from region someregion
=== Ending test "getAccountId returns an account id (happy path)" ===

=== Starting test "getAccountId returns undefined if getCallerIdentity returns an undefined account" ===
Getting AccountId from region someregion
=== Ending test "getAccountId returns undefined if getCallerIdentity returns an undefined account" ===

=== Starting test "getAccountId returns undefined if getCallerIdentity throws" ===
Getting AccountId from region someregion
Error getting AccountId
Error: Simulating service error
=== Ending test "getAccountId returns undefined if getCallerIdentity throws" ===

=== Starting test "getAccountId returns undefined if STS is not defined and toolkitClientBuilder cannot create an STS client" ===
Getting AccountId from region someregion
Error getting AccountId
Error: Simulating STS Client not creating
=== Ending test "getAccountId returns undefined if STS is not defined and toolkitClientBuilder cannot create an STS client" ===

=== Starting test "CredentialsProfileMru lists no profile when none exist" ===
=== Ending test "CredentialsProfileMru lists no profile when none exist" ===

=== Starting test "CredentialsProfileMru lists single profile when only one exists" ===
=== Ending test "CredentialsProfileMru lists single profile when only one exists" ===

=== Starting test "CredentialsProfileMru lists multiple profiles when multiple exist" ===
=== Ending test "CredentialsProfileMru lists multiple profiles when multiple exist" ===

=== Starting test "CredentialsProfileMru does not list duplicate profiles" ===
=== Ending test "CredentialsProfileMru does not list duplicate profiles" ===

=== Starting test "CredentialsProfileMru does not list more than MAX_CRENDTIAL_MRU_SIZE profiles" ===
=== Ending test "CredentialsProfileMru does not list more than MAX_CRENDTIAL_MRU_SIZE profiles" ===

=== Starting test "CredentialsStore getCredentials returns undefined when credentials are not loaded" ===
=== Ending test "CredentialsStore getCredentials returns undefined when credentials are not loaded" ===

=== Starting test "CredentialsStore getOrCreateCredentials creates when credentials are not loaded" ===
=== Ending test "CredentialsStore getOrCreateCredentials creates when credentials are not loaded" ===

=== Starting test "CredentialsStore getOrCreateCredentials does not call create method once credentials are loaded" ===
=== Ending test "CredentialsStore getOrCreateCredentials does not call create method once credentials are loaded" ===

=== Starting test "CredentialsStore getCredentials returns stored credentials" ===
=== Ending test "CredentialsStore getCredentials returns stored credentials" ===

=== Starting test "CredentialsStore invalidate removes the credentials from storage" ===
=== Ending test "CredentialsStore invalidate removes the credentials from storage" ===

=== Starting test "defaultCredentialSelectionDataProvider credentialProfileSelector stops on selection of existing profile name" ===
=== Ending test "defaultCredentialSelectionDataProvider credentialProfileSelector stops on selection of existing profile name" ===

=== Starting test "defaultCredentialSelectionDataProvider promptToDefineCredentialsProfile populates prompt with profiles from from data provider" ===
=== Ending test "defaultCredentialSelectionDataProvider promptToDefineCredentialsProfile populates prompt with profiles from from data provider" ===

=== Starting test "LoginManager logs in with credentials (happy path)" ===
Credentials for test:someId have changed, using updated credentials.
=== Ending test "LoginManager logs in with credentials (happy path)" ===

=== Starting test "LoginManager logs out (happy path)" ===
Credentials for test:someId have changed, using updated credentials.
=== Ending test "LoginManager logs out (happy path)" ===

=== Starting test "LoginManager logs out if credentials could not be retrieved" ===
Error trying to connect to AWS with Credentials Provider test:someId. Toolkit will now disconnect from AWS.
Error: Could not find Credentials Provider for test:someId
=== Ending test "LoginManager logs out if credentials could not be retrieved" ===

=== Starting test "LoginManager logs out if an account Id could not be determined" ===
Credentials for test:someId have changed, using updated credentials.
Error trying to connect to AWS with Credentials Provider test:someId. Toolkit will now disconnect from AWS.
Error: Could not determine Account Id for credentials
=== Ending test "LoginManager logs out if an account Id could not be determined" ===

=== Starting test "LoginManager logs out if getting an account Id throws an Error" ===
Credentials for test:someId have changed, using updated credentials.
Error trying to connect to AWS with Credentials Provider test:someId. Toolkit will now disconnect from AWS.
Simulating getAccountId throwing an Error
=== Ending test "LoginManager logs out if getting an account Id throws an Error" ===

=== Starting test "UserCredentialsUtils findExistingCredentialsFilenames returns both filenames if both files exist" ===
=== Ending test "UserCredentialsUtils findExistingCredentialsFilenames returns both filenames if both files exist" ===

=== Starting test "UserCredentialsUtils findExistingCredentialsFilenames returns credentials file if it exists and config file does not exist" ===
=== Ending test "UserCredentialsUtils findExistingCredentialsFilenames returns credentials file if it exists and config file does not exist" ===

=== Starting test "UserCredentialsUtils findExistingCredentialsFilenames returns config file if it exists and credentials file does not exist" ===
=== Ending test "UserCredentialsUtils findExistingCredentialsFilenames returns config file if it exists and credentials file does not exist" ===

=== Starting test "UserCredentialsUtils findExistingCredentialsFilenames returns empty result if neither file exists" ===
=== Ending test "UserCredentialsUtils findExistingCredentialsFilenames returns empty result if neither file exists" ===

=== Starting test "UserCredentialsUtils generateCredentialsFile generates a valid credentials file" ===
=== Ending test "UserCredentialsUtils generateCredentialsFile generates a valid credentials file" ===

=== Starting test "DefaultAwsClientBuilder createAndConfigureSdkClient includes custom user-agent if no options are specified" ===
=== Ending test "DefaultAwsClientBuilder createAndConfigureSdkClient includes custom user-agent if no options are specified" ===

=== Starting test "DefaultAwsClientBuilder createAndConfigureSdkClient includes custom user-agent if not specified in options" ===
=== Ending test "DefaultAwsClientBuilder createAndConfigureSdkClient includes custom user-agent if not specified in options" ===

=== Starting test "DefaultAwsClientBuilder createAndConfigureSdkClient does not override custom user-agent if specified in options" ===
=== Ending test "DefaultAwsClientBuilder createAndConfigureSdkClient does not override custom user-agent if specified in options" ===

=== Starting test "DefaultAwsContext instantiates with no credentials" ===
=== Ending test "DefaultAwsContext instantiates with no credentials" ===

=== Starting test "DefaultAwsContext sets credentials and gets credentialsId" ===
=== Ending test "DefaultAwsContext sets credentials and gets credentialsId" ===

=== Starting test "DefaultAwsContext sets undefined credentials and gets credentialsId" ===
=== Ending test "DefaultAwsContext sets undefined credentials and gets credentialsId" ===

=== Starting test "DefaultAwsContext sets credentials and gets accountId" ===
=== Ending test "DefaultAwsContext sets credentials and gets accountId" ===

=== Starting test "DefaultAwsContext sets undefined credentials and gets accountId" ===
=== Ending test "DefaultAwsContext sets undefined credentials and gets accountId" ===

=== Starting test "DefaultAwsContext sets credentials and gets credentials" ===
=== Ending test "DefaultAwsContext sets credentials and gets credentials" ===

=== Starting test "DefaultAwsContext sets undefined credentials and gets credentials" ===
=== Ending test "DefaultAwsContext sets undefined credentials and gets credentials" ===

=== Starting test "DefaultAwsContext gets single region from config on startup" ===
=== Ending test "DefaultAwsContext gets single region from config on startup" ===

=== Starting test "DefaultAwsContext gets multiple regions from config on startup" ===
=== Ending test "DefaultAwsContext gets multiple regions from config on startup" ===

=== Starting test "DefaultAwsContext updates globalState on single region change" ===
=== Ending test "DefaultAwsContext updates globalState on single region change" ===

=== Starting test "DefaultAwsContext updates globalState on multiple region change" ===
=== Ending test "DefaultAwsContext updates globalState on multiple region change" ===

=== Starting test "DefaultAwsContext updates globalState on region removal" ===
=== Ending test "DefaultAwsContext updates globalState on region removal" ===

=== Starting test "DefaultAwsContext fires event on credentials change" ===
=== Ending test "DefaultAwsContext fires event on credentials change" ===

=== Starting test "extensionUtilities safeGet can access sub-property" ===
=== Ending test "extensionUtilities safeGet can access sub-property" ===

=== Starting test "extensionUtilities createQuickStartWebview throws error if a quick start page doesn' exist" ===
=== Ending test "extensionUtilities createQuickStartWebview throws error if a quick start page doesn' exist" ===

=== Starting test "extensionUtilities createQuickStartWebview returns a webview with unaltered text if a valid file is passed without tokens" ===
=== Ending test "extensionUtilities createQuickStartWebview returns a webview with unaltered text if a valid file is passed without tokens" ===

=== Starting test "extensionUtilities createQuickStartWebview returns a webview with tokens replaced" ===
=== Ending test "extensionUtilities createQuickStartWebview returns a webview with tokens replaced" ===

=== Starting test "extensionUtilities isDifferentVersion returns false if the version exists and matches the existing version exactly" ===
=== Ending test "extensionUtilities isDifferentVersion returns false if the version exists and matches the existing version exactly" ===

=== Starting test "extensionUtilities isDifferentVersion returns true if a most recent version isn't set" ===
=== Ending test "extensionUtilities isDifferentVersion returns true if a most recent version isn't set" ===

=== Starting test "extensionUtilities isDifferentVersion returns true if a most recent version doesn't match the current version" ===
=== Ending test "extensionUtilities isDifferentVersion returns true if a most recent version doesn't match the current version" ===

=== Starting test "extensionUtilities setMostRecentVersion sets the most recent version" ===
=== Ending test "extensionUtilities setMostRecentVersion sets the most recent version" ===

=== Starting test "FeatureToggle isFeatureActive returns true if feature is declared active and is present in settings.json" ===
=== Ending test "FeatureToggle isFeatureActive returns true if feature is declared active and is present in settings.json" ===

=== Starting test "FeatureToggle isFeatureActive returns false for features that are not declared as active feature keys but are present in settings.json" ===
=== Ending test "FeatureToggle isFeatureActive returns false for features that are not declared as active feature keys but are present in settings.json" ===

=== Starting test "FeatureToggle isFeatureActive returns false for features that are declared as active feature keys but are not active in settings.json" ===
=== Ending test "FeatureToggle isFeatureActive returns false for features that are declared as active feature keys but are not active in settings.json" ===

=== Starting test "FeatureToggle isFeatureActive throws an error if too many features are registered" ===
=== Ending test "FeatureToggle isFeatureActive throws an error if too many features are registered" ===

=== Starting test "filesystem mkdir makes subfolder to existing folder" ===
=== Ending test "filesystem mkdir makes subfolder to existing folder" ===

=== Starting test "filesystem mkdir makes two levels of subfolders" ===
=== Ending test "filesystem mkdir makes two levels of subfolders" ===

=== Starting test "filesystem mkdir makes many levels of subfolders" ===
=== Ending test "filesystem mkdir makes many levels of subfolders" ===

=== Starting test "filesystem rmrf deletes files and folders recursively" ===
=== Ending test "filesystem rmrf deletes files and folders recursively" ===

=== Starting test "filesystemUtilities makeTemporaryToolkitFolder makes temp dirs as children to filesystemUtilities.tempDirPath ('/tmp/aws-toolkit-vscode')" ===
=== Ending test "filesystemUtilities makeTemporaryToolkitFolder makes temp dirs as children to filesystemUtilities.tempDirPath ('/tmp/aws-toolkit-vscode')" ===

=== Starting test "filesystemUtilities makeTemporaryToolkitFolder creates a folder" ===
=== Ending test "filesystemUtilities makeTemporaryToolkitFolder creates a folder" ===

=== Starting test "filesystemUtilities makeTemporaryToolkitFolder makes nested temp dirs" ===
=== Ending test "filesystemUtilities makeTemporaryToolkitFolder makes nested temp dirs" ===

=== Starting test "filesystemUtilities findFileInParentPaths returns undefined when file not found" ===
=== Ending test "filesystemUtilities findFileInParentPaths returns undefined when file not found" ===

=== Starting test "filesystemUtilities findFileInParentPaths finds the file in the same folder" ===
=== Ending test "filesystemUtilities findFileInParentPaths finds the file in the same folder" ===

=== Starting test "filesystemUtilities findFileInParentPaths finds the file next to another file" ===
=== Ending test "filesystemUtilities findFileInParentPaths finds the file next to another file" ===

=== Starting test "filesystemUtilities findFileInParentPaths finds the file in the parent folder" ===
=== Ending test "filesystemUtilities findFileInParentPaths finds the file in the parent folder" ===

=== Starting test "filesystemUtilities findFileInParentPaths finds the file 3 parent folders up" ===
=== Ending test "filesystemUtilities findFileInParentPaths finds the file 3 parent folders up" ===

=== Starting test "filesystemUtilities isContainedWithinDirectory returns true for the same dir" ===
=== Ending test "filesystemUtilities isContainedWithinDirectory returns true for the same dir" ===

=== Starting test "filesystemUtilities isContainedWithinDirectory returns true for a subdir" ===
=== Ending test "filesystemUtilities isContainedWithinDirectory returns true for a subdir" ===

=== Starting test "filesystemUtilities isContainedWithinDirectory returns true for a file in the same dir" ===
=== Ending test "filesystemUtilities isContainedWithinDirectory returns true for a file in the same dir" ===

=== Starting test "filesystemUtilities isContainedWithinDirectory returns true for a file in a subdir" ===
=== Ending test "filesystemUtilities isContainedWithinDirectory returns true for a file in a subdir" ===

=== Starting test "filesystemUtilities isContainedWithinDirectory returns false for a completely different dir" ===
=== Ending test "filesystemUtilities isContainedWithinDirectory returns false for a completely different dir" ===

=== Starting test "filesystemUtilities isContainedWithinDirectory returns false for a similarly named dir" ===
=== Ending test "filesystemUtilities isContainedWithinDirectory returns false for a similarly named dir" ===

=== Starting test "makeLogger creates a logger object" ===
=== Ending test "makeLogger creates a logger object" ===

=== Starting test "OutputChannelTransport logs content" ===
=== Ending test "OutputChannelTransport logs content" ===

=== Starting test "WinstonToolkitLogger creates an object" ===
=== Ending test "WinstonToolkitLogger creates an object" ===

=== Starting test "WinstonToolkitLogger throws when logging to a disposed object" ===
=== Ending test "WinstonToolkitLogger throws when logging to a disposed object" ===

=== Starting test "WinstonToolkitLogger logs to a file does not log a lower level" ===
=== Ending test "WinstonToolkitLogger logs to a file does not log a lower level" ===

=== Starting test "WinstonToolkitLogger logs to a file logs multiple inputs" ===
=== Ending test "WinstonToolkitLogger logs to a file logs multiple inputs" ===

=== Starting test "WinstonToolkitLogger logs to a file supports updating the log type" ===
=== Ending test "WinstonToolkitLogger logs to a file supports updating the log type" ===

=== Starting test "WinstonToolkitLogger logs to a file logs debug" ===
=== Ending test "WinstonToolkitLogger logs to a file logs debug" ===

=== Starting test "WinstonToolkitLogger logs to a file logs verbose" ===
=== Ending test "WinstonToolkitLogger logs to a file logs verbose" ===

=== Starting test "WinstonToolkitLogger logs to a file logs info" ===
=== Ending test "WinstonToolkitLogger logs to a file logs info" ===

=== Starting test "WinstonToolkitLogger logs to a file logs warn" ===
=== Ending test "WinstonToolkitLogger logs to a file logs warn" ===

=== Starting test "WinstonToolkitLogger logs to a file logs error" ===
=== Ending test "WinstonToolkitLogger logs to a file logs error" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel does not log a lower level" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel does not log a lower level" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel logs multiple inputs" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel logs multiple inputs" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel supports updating the log type" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel supports updating the log type" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel logs debug" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel logs debug" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel logs verbose" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel logs verbose" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel logs info" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel logs info" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel logs warn" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel logs warn" ===

=== Starting test "WinstonToolkitLogger logs to an OutputChannel logs error" ===
=== Ending test "WinstonToolkitLogger logs to an OutputChannel logs error" ===

=== Starting test "DefaultRegionProvider isServiceInRegion indicates when a service is in a region" ===
=== Ending test "DefaultRegionProvider isServiceInRegion indicates when a service is in a region" ===

=== Starting test "DefaultRegionProvider isServiceInRegion indicates when a service is not in a region" ===
=== Ending test "DefaultRegionProvider isServiceInRegion indicates when a service is not in a region" ===

=== Starting test "DefaultRegionProvider getPartitionId gets partition for a known region" ===
Retrieving AWS endpoint data
=== Ending test "DefaultRegionProvider getPartitionId gets partition for a known region" ===

=== Starting test "DefaultRegionProvider getPartitionId returns undefined for an unknown region" ===
Retrieving AWS endpoint data
Unable to determine the Partition that Region foo belongs to
=== Ending test "DefaultRegionProvider getPartitionId returns undefined for an unknown region" ===

=== Starting test "DefaultRegionProvider getRegions gets regions for a known partition" ===
Retrieving AWS endpoint data
=== Ending test "DefaultRegionProvider getRegions gets regions for a known partition" ===

=== Starting test "DefaultRegionProvider getRegions returns empty array for an unknown partition" ===
Retrieving AWS endpoint data
=== Ending test "DefaultRegionProvider getRegions returns empty array for an unknown partition" ===

=== Starting test "loadEndpoints returns undefined for malformed json" ===
Failed to load endpoints manifest
SyntaxError: Unexpected token f in JSON at position 2
endpoints payload was:
{ foo: 
=== Ending test "loadEndpoints returns undefined for malformed json" ===

=== Starting test "loadEndpoints returns an object for well-formed json" ===
=== Ending test "loadEndpoints returns an object for well-formed json" ===

=== Starting test "loadEndpoints loads partitions" ===
=== Ending test "loadEndpoints loads partitions" ===

=== Starting test "loadEndpoints loads regions" ===
=== Ending test "loadEndpoints loads regions" ===

=== Starting test "loadEndpoints loads services" ===
=== Ending test "loadEndpoints loads services" ===

=== Starting test "EndpointsProvider loads from local fetcher" ===
Retrieving AWS endpoint data
=== Ending test "EndpointsProvider loads from local fetcher" ===

=== Starting test "EndpointsProvider loads from remote fetcher" ===
Retrieving AWS endpoint data
=== Ending test "EndpointsProvider loads from remote fetcher" ===

=== Starting test "EndpointsProvider raises events after each fetcher" ===
Retrieving AWS endpoint data
=== Ending test "EndpointsProvider raises events after each fetcher" ===

=== Starting test "EndpointsProvider does not raise an event if local fetcher returns nothing" ===
Retrieving AWS endpoint data
=== Ending test "EndpointsProvider does not raise an event if local fetcher returns nothing" ===

=== Starting test "EndpointsProvider does not raise an event if remote fetcher returns nothing" ===
Retrieving AWS endpoint data
=== Ending test "EndpointsProvider does not raise an event if remote fetcher returns nothing" ===

=== Starting test "getRegionsForActiveCredentials returns regions in the same partition" ===
=== Ending test "getRegionsForActiveCredentials returns regions in the same partition" ===

=== Starting test "getRegionsForActiveCredentials defaults to the standard partition if no default region is found" ===
=== Ending test "getRegionsForActiveCredentials defaults to the standard partition if no default region is found" ===

=== Starting test "getRegionsForActiveCredentials defaults to the standard partition if default region is not recognized" ===
=== Ending test "getRegionsForActiveCredentials defaults to the standard partition if default region is not recognized" ===

=== Starting test "CompositeResourceFetcher loads from a resource fetcher" ===
=== Ending test "CompositeResourceFetcher loads from a resource fetcher" ===

=== Starting test "CompositeResourceFetcher loads from the first resource fetcher to return contents" ===
=== Ending test "CompositeResourceFetcher loads from the first resource fetcher to return contents" ===

=== Starting test "CompositeResourceFetcher tries to load from the next resource fetcher when one raises an error" ===
Error loading resource from resource fetcher
AssertionError [ERR_ASSERTION]: Error, load from the next fetcher
=== Ending test "CompositeResourceFetcher tries to load from the next resource fetcher when one raises an error" ===

=== Starting test "CompositeResourceFetcher returns undefined if no resource fetcher returns contents" ===
=== Ending test "CompositeResourceFetcher returns undefined if no resource fetcher returns contents" ===

=== Starting test "FileResourceFetcher loads the contents of a file" ===
Loading resource from /tmp/aws-toolkit-vscode/vsctkbclWIo/file.txt
=== Ending test "FileResourceFetcher loads the contents of a file" ===

=== Starting test "FileResourceFetcher returns undefined if the file does not exist" ===
Loading resource from /tmp/aws-toolkit-vscode/vsctkKh9R0X/somefile
Error loading resource from /tmp/aws-toolkit-vscode/vsctkKh9R0X/somefile
Error: ENOENT: no such file or directory, open '/tmp/aws-toolkit-vscode/vsctkKh9R0X/somefile'
=== Ending test "FileResourceFetcher returns undefined if the file does not exist" ===

=== Starting test "DefaultValidatingSamCliProcessInvoker throws InvalidSamCliVersionError when validation reports SAM CLI Version is too low" ===
=== Ending test "DefaultValidatingSamCliProcessInvoker throws InvalidSamCliVersionError when validation reports SAM CLI Version is too low" ===

=== Starting test "DefaultValidatingSamCliProcessInvoker throws InvalidSamCliVersionError when validation reports SAM CLI Version is too high" ===
=== Ending test "DefaultValidatingSamCliProcessInvoker throws InvalidSamCliVersionError when validation reports SAM CLI Version is too high" ===

=== Starting test "DefaultValidatingSamCliProcessInvoker throws InvalidSamCliVersionError when validation reports SAM CLI Version is unparsable" ===
=== Ending test "DefaultValidatingSamCliProcessInvoker throws InvalidSamCliVersionError when validation reports SAM CLI Version is unparsable" ===

=== Starting test "DefaultValidatingSamCliProcessInvoker throws SamCliNotFoundError when sam cli cannot be found" ===
=== Ending test "DefaultValidatingSamCliProcessInvoker throws SamCliNotFoundError when sam cli cannot be found" ===

=== Starting test "DefaultValidatingSamCliProcessInvoker throws Error when given invalid validation state" ===
=== Ending test "DefaultValidatingSamCliProcessInvoker throws Error when given invalid validation state" ===

=== Starting test "DefaultValidatingSamCliProcessInvoker invokes when there are no validation issues" ===
=== Ending test "DefaultValidatingSamCliProcessInvoker invokes when there are no validation issues" ===

=== Starting test "SamCliBuildInvocation Passes build command to sam cli" ===
=== Ending test "SamCliBuildInvocation Passes build command to sam cli" ===

=== Starting test "SamCliBuildInvocation Passes Build Dir to sam cli" ===
=== Ending test "SamCliBuildInvocation Passes Build Dir to sam cli" ===

=== Starting test "SamCliBuildInvocation Passes Base Dir to sam cli" ===
=== Ending test "SamCliBuildInvocation Passes Base Dir to sam cli" ===

=== Starting test "SamCliBuildInvocation Does not pass Base Dir to sam cli" ===
=== Ending test "SamCliBuildInvocation Does not pass Base Dir to sam cli" ===

=== Starting test "SamCliBuildInvocation Passes Template to sam cli" ===
=== Ending test "SamCliBuildInvocation Passes Template to sam cli" ===

=== Starting test "SamCliBuildInvocation passes --use-container to sam cli if useContainer is true" ===
=== Ending test "SamCliBuildInvocation passes --use-container to sam cli if useContainer is true" ===

=== Starting test "SamCliBuildInvocation does not pass --use-container to sam cli if useContainer is false" ===
=== Ending test "SamCliBuildInvocation does not pass --use-container to sam cli if useContainer is false" ===

=== Starting test "SamCliBuildInvocation does not pass --use-container to sam cli if useContainer is undefined" ===
=== Ending test "SamCliBuildInvocation does not pass --use-container to sam cli if useContainer is undefined" ===

=== Starting test "SamCliBuildInvocation passes --manifest to sam cli if manifestPath is set" ===
=== Ending test "SamCliBuildInvocation passes --manifest to sam cli if manifestPath is set" ===

=== Starting test "SamCliBuildInvocation does not pass --manifest to sam cli if manifestPath is not set" ===
=== Ending test "SamCliBuildInvocation does not pass --manifest to sam cli if manifestPath is not set" ===

=== Starting test "SamCliBuildInvocation Passes docker network to sam cli" ===
=== Ending test "SamCliBuildInvocation Passes docker network to sam cli" ===

=== Starting test "SamCliBuildInvocation Does not pass docker network to sam cli if undefined" ===
=== Ending test "SamCliBuildInvocation Does not pass docker network to sam cli if undefined" ===

=== Starting test "SamCliBuildInvocation passes --skip-pull-image to sam cli if skipPullImage is true" ===
=== Ending test "SamCliBuildInvocation passes --skip-pull-image to sam cli if skipPullImage is true" ===

=== Starting test "SamCliBuildInvocation does not pass --skip-pull-image to sam cli if skipPullImageis false" ===
=== Ending test "SamCliBuildInvocation does not pass --skip-pull-image to sam cli if skipPullImageis false" ===

=== Starting test "SamCliBuildInvocation does not pass --skip-pull-image to sam cli if skipPullImage is undefined" ===
=== Ending test "SamCliBuildInvocation does not pass --skip-pull-image to sam cli if skipPullImage is undefined" ===

=== Starting test "SamCliBuildInvocation throws on unexpected exit code" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: Bad Result
stderr: stderr message
stdout: stdout message
=== Ending test "SamCliBuildInvocation throws on unexpected exit code" ===

=== Starting test "SamCliConfiguration uses config value when referencing file that exists" ===
=== Ending test "SamCliConfiguration uses config value when referencing file that exists" ===

=== Starting test "SamCliConfiguration calls location provider when config references file that does not exist" ===
=== Ending test "SamCliConfiguration calls location provider when config references file that does not exist" ===

=== Starting test "SamCliConfiguration calls location provider when config not set" ===
=== Ending test "SamCliConfiguration calls location provider when config not set" ===

=== Starting test "SamCliConfiguration location provider detects a file" ===
=== Ending test "SamCliConfiguration location provider detects a file" ===

=== Starting test "SamCliConfiguration location provider does not detect a file" ===
=== Ending test "SamCliConfiguration location provider does not detect a file" ===

=== Starting test "runSamCliDeploy does not include --parameter-overrides if there are no overrides" ===
=== Ending test "runSamCliDeploy does not include --parameter-overrides if there are no overrides" ===

=== Starting test "runSamCliDeploy includes overrides as a string of key=value pairs" ===
=== Ending test "runSamCliDeploy includes overrides as a string of key=value pairs" ===

=== Starting test "runSamCliDeploy includes a template, stack name, and region" ===
=== Ending test "runSamCliDeploy includes a template, stack name, and region" ===

=== Starting test "runSamCliDeploy throws on unexpected exit code" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: Bad Result
stderr: stderr message
stdout: stdout message
=== Ending test "runSamCliDeploy throws on unexpected exit code" ===

=== Starting test "SamCliInfoInvocation converts sam info response to SamCliInfoResponse" ===
=== Ending test "SamCliInfoInvocation converts sam info response to SamCliInfoResponse" ===

=== Starting test "SamCliInfoInvocation converts sam info response containing unexpected fields to SamCliInfoResponse" ===
=== Ending test "SamCliInfoInvocation converts sam info response containing unexpected fields to SamCliInfoResponse" ===

=== Starting test "SamCliInfoInvocation converts sam info response without version to SamCliInfoResponse" ===
=== Ending test "SamCliInfoInvocation converts sam info response without version to SamCliInfoResponse" ===

=== Starting test "SamCliInfoInvocation converts non-response to undefined" ===
SyntaxError: Unexpected token q in JSON at position 0
SyntaxError: Unexpected token y in JSON at position 21
=== Ending test "SamCliInfoInvocation converts non-response to undefined" ===

=== Starting test "SamCliInfoInvocation handles successful errorcode and output" ===
=== Ending test "SamCliInfoInvocation handles successful errorcode and output" ===

=== Starting test "SamCliInfoInvocation handles successful errorcode with strange output" ===
SyntaxError: Unexpected token u in JSON at position 0
=== Ending test "SamCliInfoInvocation handles successful errorcode with strange output" ===

=== Starting test "SamCliInfoInvocation throws on unexpected exit code" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: Bad Result
stderr: stderr message
stdout: stdout message
=== Ending test "SamCliInfoInvocation throws on unexpected exit code" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template Passes init command to sam cli" ===
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template Passes init command to sam cli" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template Passes name to sam cli" ===
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template Passes name to sam cli" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template Passes location to sam cli" ===
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template Passes location to sam cli" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template Passes runtime to sam cli" ===
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template Passes runtime to sam cli" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template throws on unexpected exit code" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: Bad Result
stderr: stderr message
stdout: stdout message
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template throws on unexpected exit code" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template Passes --no-interactive" ===
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template Passes --no-interactive" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template Passes --app-template" ===
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template Passes --app-template" ===

=== Starting test "runSamCliInit runSamCliInit with HelloWorld template Passes --dependency-manager" ===
=== Ending test "runSamCliInit runSamCliInit with HelloWorld template Passes --dependency-manager" ===

=== Starting test "runSamCliInit runSamCliInit With EventBridgeStartAppTemplate Passes --extra-context for eventBridgeStarterAppTemplate" ===
=== Ending test "runSamCliInit runSamCliInit With EventBridgeStartAppTemplate Passes --extra-context for eventBridgeStarterAppTemplate" ===

=== Starting test "DefaultSamCliProcessInvoker throws if sam cli location is not known" ===
Error: SAM CLI location not configured
=== Ending test "DefaultSamCliProcessInvoker throws if sam cli location is not known" ===

=== Starting test "logAndThrowIfUnexpectedExitCode does not throw on expected exit code" ===
=== Ending test "logAndThrowIfUnexpectedExitCode does not throw on expected exit code" ===

=== Starting test "logAndThrowIfUnexpectedExitCode throws on unexpected exit code" ===
Unexpected exitcode (123), expecting (456)
Error: Error: bad result
stderr: stderr text
stdout: stdout text
=== Ending test "logAndThrowIfUnexpectedExitCode throws on unexpected exit code" ===

=== Starting test "SamCliLocalInvokeInvocation Passes local invoke command to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes local invoke command to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Passes template resource name to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes template resource name to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Passes template path to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes template path to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Passes event path to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes event path to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Passes env-vars path to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes env-vars path to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Passes debug port to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes debug port to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation undefined debug port does not pass to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation undefined debug port does not pass to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Passes docker network to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes docker network to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Does not pass docker network to sam cli when undefined" ===
=== Ending test "SamCliLocalInvokeInvocation Does not pass docker network to sam cli when undefined" ===

=== Starting test "SamCliLocalInvokeInvocation passes --skip-pull-image to sam cli if skipPullImage is true" ===
=== Ending test "SamCliLocalInvokeInvocation passes --skip-pull-image to sam cli if skipPullImage is true" ===

=== Starting test "SamCliLocalInvokeInvocation does not pass --skip-pull-image to sam cli if skipPullImage is false" ===
=== Ending test "SamCliLocalInvokeInvocation does not pass --skip-pull-image to sam cli if skipPullImage is false" ===

=== Starting test "SamCliLocalInvokeInvocation does not pass --skip-pull-image to sam cli if skipPullImage is undefined" ===
=== Ending test "SamCliLocalInvokeInvocation does not pass --skip-pull-image to sam cli if skipPullImage is undefined" ===

=== Starting test "SamCliLocalInvokeInvocation Passes debuggerPath to sam cli" ===
=== Ending test "SamCliLocalInvokeInvocation Passes debuggerPath to sam cli" ===

=== Starting test "SamCliLocalInvokeInvocation Does not pass debuggerPath to sam cli when undefined" ===
=== Ending test "SamCliLocalInvokeInvocation Does not pass debuggerPath to sam cli when undefined" ===

=== Starting test "SamCliPackageInvocation includes a template, s3 bucket, output template file, and region" ===
=== Ending test "SamCliPackageInvocation includes a template, s3 bucket, output template file, and region" ===

=== Starting test "SamCliPackageInvocation throws on unexpected exit code" ===
Unexpected exitcode (-1), expecting (0)
Error: Error: Bad Result
stderr: stderr message
stdout: stdout message
=== Ending test "SamCliPackageInvocation throws on unexpected exit code" ===

=== Starting test "makeSamCliValidationNotification handles SamCliNotFoundError" ===
=== Ending test "makeSamCliValidationNotification handles SamCliNotFoundError" ===

=== Starting test "makeSamCliValidationNotification handles InvalidSamCliVersionError - SAM CLI Version is too low" ===
=== Ending test "makeSamCliValidationNotification handles InvalidSamCliVersionError - SAM CLI Version is too low" ===

=== Starting test "makeSamCliValidationNotification handles InvalidSamCliVersionError - SAM CLI Version is too high" ===
=== Ending test "makeSamCliValidationNotification handles InvalidSamCliVersionError - SAM CLI Version is too high" ===

=== Starting test "makeSamCliValidationNotification handles InvalidSamCliVersionError - SAM CLI Version is unparsable" ===
=== Ending test "makeSamCliValidationNotification handles InvalidSamCliVersionError - SAM CLI Version is unparsable" ===

=== Starting test "makeSamCliValidationNotification handles Unexpected input" ===
=== Ending test "makeSamCliValidationNotification handles Unexpected input" ===

=== Starting test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is valid" ===
=== Ending test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is valid" ===

=== Starting test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is too low" ===
=== Ending test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is too low" ===

=== Starting test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is too high" ===
=== Ending test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is too high" ===

=== Starting test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is unparsable - empty string" ===
=== Ending test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is unparsable - empty string" ===

=== Starting test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is unparsable - random text" ===
=== Ending test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI exists and SAM CLI Version is unparsable - random text" ===

=== Starting test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI is not found" ===
=== Ending test "DefaultSamCliValidator detectValidSamCli handles case where SAM CLI is not found" ===

=== Starting test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is valid" ===
=== Ending test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is valid" ===

=== Starting test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is too low" ===
=== Ending test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is too low" ===

=== Starting test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is too high" ===
=== Ending test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is too high" ===

=== Starting test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is unparsable - empty string" ===
=== Ending test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is unparsable - empty string" ===

=== Starting test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is unparsable - random text" ===
=== Ending test "DefaultSamCliValidator getVersionValidatorResult Validates SAM CLI binary for the case: SAM CLI Version is unparsable - random text" ===

=== Starting test "DefaultSamCliValidator getVersionValidatorResult Uses the cached validation result" ===
=== Ending test "DefaultSamCliValidator getVersionValidatorResult Uses the cached validation result" ===

=== Starting test "DefaultSamCliValidator getVersionValidatorResult Does not use the cached validation result if the SAM CLI timestamp changed" ===
=== Ending test "DefaultSamCliValidator getVersionValidatorResult Does not use the cached validation result if the SAM CLI timestamp changed" ===

=== Starting test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is valid" ===
=== Ending test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is valid" ===

=== Starting test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is too low" ===
=== Ending test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is too low" ===

=== Starting test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is too high" ===
=== Ending test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is too high" ===

=== Starting test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is unparsable - empty string" ===
=== Ending test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is unparsable - empty string" ===

=== Starting test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is unparsable - random text" ===
=== Ending test "DefaultSamCliValidator validateSamCliVersion validates when SAM CLI Version is unparsable - random text" ===

=== Starting test "AwsSamDebugConfigurationProvider provideDebugConfig returns undefined if no workspace folder is provided" ===
=== Ending test "AwsSamDebugConfigurationProvider provideDebugConfig returns undefined if no workspace folder is provided" ===

=== Starting test "AwsSamDebugConfigurationProvider provideDebugConfig returns a blank array if no templates are in the workspace" ===
=== Ending test "AwsSamDebugConfigurationProvider provideDebugConfig returns a blank array if no templates are in the workspace" ===

=== Starting test "AwsSamDebugConfigurationProvider provideDebugConfig returns an array with a single item if a template with one resource is in the workspace" ===
=== Ending test "AwsSamDebugConfigurationProvider provideDebugConfig returns an array with a single item if a template with one resource is in the workspace" ===

=== Starting test "AwsSamDebugConfigurationProvider provideDebugConfig returns an array with multiple items if a template with more than one resource is in the workspace" ===
=== Ending test "AwsSamDebugConfigurationProvider provideDebugConfig returns an array with multiple items if a template with more than one resource is in the workspace" ===

=== Starting test "AwsSamDebugConfigurationProvider provideDebugConfig only detects the specifically targeted workspace folder (and its subfolders)" ===
=== Ending test "AwsSamDebugConfigurationProvider provideDebugConfig only detects the specifically targeted workspace folder (and its subfolders)" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving debug configurations with an invalid request type" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving debug configurations with an invalid request type" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving debug configurations with an invalid target type" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving debug configurations with an invalid target type" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving template debug configurations with a template that isn't in the registry" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving template debug configurations with a template that isn't in the registry" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving template debug configurations with a template that doesn't have the set resource" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving template debug configurations with a template that doesn't have the set resource" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving template debug configurations with a resource that has an invalid runtime in template" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving template debug configurations with a resource that has an invalid runtime in template" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving code debug configurations with invalid runtimes" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration returns undefined when resolving code debug configurations with invalid runtimes" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration TEMP!!! - returns undefined when resolving a valid code debug configuration" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration TEMP!!! - returns undefined when resolving a valid code debug configuration" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration TEMP!!! - returns undefined when resolving a valid template debug configuration" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration TEMP!!! - returns undefined when resolving a valid template debug configuration" ===

=== Starting test "AwsSamDebugConfigurationProvider resolveDebugConfiguration TEMP!!! - returns undefined when resolving a valid template debug configuration that specifies extraneous environment variables" ===
=== Ending test "AwsSamDebugConfigurationProvider resolveDebugConfiguration TEMP!!! - returns undefined when resolving a valid template debug configuration that specifies extraneous environment variables" ===

=== Starting test "SystemUtilities getHomeDirectory gets HOME if set" ===
=== Ending test "SystemUtilities getHomeDirectory gets HOME if set" ===

=== Starting test "SystemUtilities getHomeDirectory gets USERPROFILE if set and HOME is not set" ===
=== Ending test "SystemUtilities getHomeDirectory gets USERPROFILE if set and HOME is not set" ===

=== Starting test "SystemUtilities getHomeDirectory gets HOMEPATH if set and HOME and USERPROFILE are not set" ===
=== Ending test "SystemUtilities getHomeDirectory gets HOMEPATH if set and HOME and USERPROFILE are not set" ===

=== Starting test "SystemUtilities getHomeDirectory prefixes result with HOMEDRIVE if set" ===
=== Ending test "SystemUtilities getHomeDirectory prefixes result with HOMEDRIVE if set" ===

=== Starting test "SystemUtilities getHomeDirectory falls back on os.homedir if no environment variables are set" ===
=== Ending test "SystemUtilities getHomeDirectory falls back on os.homedir if no environment variables are set" ===

=== Starting test "SystemUtilities fileExists returns true if file exists" ===
=== Ending test "SystemUtilities fileExists returns true if file exists" ===

=== Starting test "SystemUtilities fileExists returns false if file does not exist" ===
=== Ending test "SystemUtilities fileExists returns false if file does not exist" ===

=== Starting test "AwsTelemetryOptOut updateTelemetryConfiguration saves settings" ===
=== Ending test "AwsTelemetryOptOut updateTelemetryConfiguration saves settings" ===

=== Starting test "AwsTelemetryOptOut updateTelemetryConfiguration(TelemetryOptOutOptions.Enable) enables telemetry" ===
=== Ending test "AwsTelemetryOptOut updateTelemetryConfiguration(TelemetryOptOutOptions.Enable) enables telemetry" ===

=== Starting test "AwsTelemetryOptOut updateTelemetryConfiguration(TelemetryOptOutOptions.Disable) disables telemetry" ===
=== Ending test "AwsTelemetryOptOut updateTelemetryConfiguration(TelemetryOptOutOptions.Disable) disables telemetry" ===

=== Starting test "AwsTelemetryOptOut updateTelemetryConfiguration(TelemetryOptOutOptions.SameAsVsCode) matches user setting" ===
=== Ending test "AwsTelemetryOptOut updateTelemetryConfiguration(TelemetryOptOutOptions.SameAsVsCode) matches user setting" ===

=== Starting test "DefaultTelemetryPublisher posts feedback" ===
=== Ending test "DefaultTelemetryPublisher posts feedback" ===

=== Starting test "DefaultTelemetryPublisher enqueues events" ===
=== Ending test "DefaultTelemetryPublisher enqueues events" ===

=== Starting test "DefaultTelemetryPublisher can flush single event" ===
=== Ending test "DefaultTelemetryPublisher can flush single event" ===

=== Starting test "DefaultTelemetryPublisher retains queue on flush failure" ===
=== Ending test "DefaultTelemetryPublisher retains queue on flush failure" ===

=== Starting test "DefaultTelemetryService posts feedback" ===
=== Ending test "DefaultTelemetryService posts feedback" ===

=== Starting test "DefaultTelemetryService publishes periodically if user has said ok" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService publishes periodically if user has said ok" ===

=== Starting test "DefaultTelemetryService events are kept in memory if user has not made a decision" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events are kept in memory if user has not made a decision" ===

=== Starting test "DefaultTelemetryService events automatically inject the active account id into the metadata" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events automatically inject the active account id into the metadata" ===

=== Starting test "DefaultTelemetryService events with `session` namespace do not have an account tied to them" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events with `session` namespace do not have an account tied to them" ===

=== Starting test "DefaultTelemetryService events created with a bad active account produce metadata mentioning the bad account" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events created with a bad active account produce metadata mentioning the bad account" ===

=== Starting test "DefaultTelemetryService events created prior to signing in do not have an account attached" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events created prior to signing in do not have an account attached" ===

=== Starting test "DefaultTelemetryService events are never recorded if telemetry has been disabled" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events are never recorded if telemetry has been disabled" ===

=== Starting test "DefaultTelemetryService events are cleared after user disables telemetry via prompt" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events are cleared after user disables telemetry via prompt" ===

=== Starting test "DefaultTelemetryService events are kept after user enables telemetry via prompt" ===
telemetry cache not found: 'telemetryCache'
=== Ending test "DefaultTelemetryService events are kept after user enables telemetry via prompt" ===

=== Starting test "Telemetry cache Rejects bad data" ===
Input into filterTelemetryCacheEvents:
THis isn't even valid json
is not an array!
=== Ending test "Telemetry cache Rejects bad data" ===

=== Starting test "Telemetry cache Filters out old data" ===
Item in telemetry cache: [object Object]
 has invalid data in the field 'data': [object Object]! skipping!
=== Ending test "Telemetry cache Filters out old data" ===

=== Starting test "Telemetry cache Extracts good data when there is bad data present" ===
Item in telemetry cache:
this is a string
is not an object! skipping!
Item in telemetry cache: [object Object]
 has invalid data in the field 'data': [object Object]! skipping!
=== Ending test "Telemetry cache Extracts good data when there is bad data present" ===

=== Starting test "Telemetry cache Happy path" ===
=== Ending test "Telemetry cache Happy path" ===

=== Starting test "TelemetryEventArray toMetricData strips names of invalid characters" ===
=== Ending test "TelemetryEventArray toMetricData strips names of invalid characters" ===

=== Starting test "TelemetryEventArray toMetricData maps TelemetryEvent with no data to a single MetricDatum" ===
=== Ending test "TelemetryEventArray toMetricData maps TelemetryEvent with no data to a single MetricDatum" ===

=== Starting test "TelemetryEventArray toMetricData Rejects entries that have null Value" ===
=== Ending test "TelemetryEventArray toMetricData Rejects entries that have null Value" ===

=== Starting test "TelemetryEventArray toMetricData Rejects entries that have null MetricName" ===
=== Ending test "TelemetryEventArray toMetricData Rejects entries that have null MetricName" ===

=== Starting test "TelemetryEventArray toMetricData maps TelemetryEvent with data to a multiple MetricDatum" ===
=== Ending test "TelemetryEventArray toMetricData maps TelemetryEvent with data to a multiple MetricDatum" ===

=== Starting test "ErrorNode initializes label and tooltip" ===
=== Ending test "ErrorNode initializes label and tooltip" ===

=== Starting test "ErrorNode has no children" ===
=== Ending test "ErrorNode has no children" ===

=== Starting test "makeChildrenNodes returns child nodes" ===
=== Ending test "makeChildrenNodes returns child nodes" ===

=== Starting test "makeChildrenNodes returns an error node if an error is encountered" ===
Error while getting Child nodes: loading error
=== Ending test "makeChildrenNodes returns an error node if an error is encountered" ===

=== Starting test "makeChildrenNodes returns a placeholder node if there are no child nodes" ===
=== Ending test "makeChildrenNodes returns a placeholder node if there are no child nodes" ===

=== Starting test "makeChildrenNodes returns an empty list if there are no child nodes and no placeholder" ===
=== Ending test "makeChildrenNodes returns an empty list if there are no child nodes and no placeholder" ===

=== Starting test "makeChildrenNodes sorts the child nodes" ===
=== Ending test "makeChildrenNodes sorts the child nodes" ===

=== Starting test "makeChildrenNodes does not sort the child nodes if a sort method is not provided" ===
=== Ending test "makeChildrenNodes does not sort the child nodes if a sort method is not provided" ===

=== Starting test "UI buttons creates a help button without a tooltip" ===
=== Ending test "UI buttons creates a help button without a tooltip" ===

=== Starting test "UI buttons creates a help button with a tooltip" ===
=== Ending test "UI buttons creates a help button with a tooltip" ===

=== Starting test "createInputBox Sets buttons" ===
=== Ending test "createInputBox Sets buttons" ===

=== Starting test "createInputBox Sets Options" ===
=== Ending test "createInputBox Sets Options" ===

=== Starting test "createInputBox Sets boolean Options to false values" ===
=== Ending test "createInputBox Sets boolean Options to false values" ===

=== Starting test "createInputBox Sets Options to undefined values" ===
=== Ending test "createInputBox Sets Options to undefined values" ===

=== Starting test "createInputBox Does not set Options" ===
=== Ending test "createInputBox Does not set Options" ===

=== Starting test "promptUser Accepted value is returned" ===
=== Ending test "promptUser Accepted value is returned" ===

=== Starting test "promptUser Hide returns undefined" ===
=== Ending test "promptUser Hide returns undefined" ===

=== Starting test "promptUser Button can cancel and return undefined" ===
=== Ending test "promptUser Button can cancel and return undefined" ===

=== Starting test "promptUser Button can return a value" ===
=== Ending test "promptUser Button can return a value" ===

=== Starting test "promptUser Button can do something and leave input box open" ===
=== Ending test "promptUser Button can do something and leave input box open" ===

=== Starting test "createQuickPick Sets items" ===
=== Ending test "createQuickPick Sets items" ===

=== Starting test "createQuickPick Sets item options" ===
=== Ending test "createQuickPick Sets item options" ===

=== Starting test "createQuickPick Sets buttons" ===
=== Ending test "createQuickPick Sets buttons" ===

=== Starting test "createQuickPick Sets Options" ===
=== Ending test "createQuickPick Sets Options" ===

=== Starting test "createQuickPick Sets boolean Options to false values" ===
=== Ending test "createQuickPick Sets boolean Options to false values" ===

=== Starting test "createQuickPick Sets Options to undefined values" ===
=== Ending test "createQuickPick Sets Options to undefined values" ===

=== Starting test "createQuickPick Does not set Options" ===
=== Ending test "createQuickPick Does not set Options" ===

=== Starting test "promptUser Accepted value is returned" ===
=== Ending test "promptUser Accepted value is returned" ===

=== Starting test "promptUser Hide returns undefined" ===
=== Ending test "promptUser Hide returns undefined" ===

=== Starting test "promptUser Button can cancel and return undefined" ===
=== Ending test "promptUser Button can cancel and return undefined" ===

=== Starting test "promptUser Button can return a value" ===
=== Ending test "promptUser Button can return a value" ===

=== Starting test "promptUser Button can do something and leave picker open" ===
=== Ending test "promptUser Button can do something and leave picker open" ===

=== Starting test "ChildProcess run runs and captures stdout - unix" ===
Running command: /tmp/aws-toolkit-vscode/vsctkVWOGTV/test-script.sh 
=== Ending test "ChildProcess run runs and captures stdout - unix" ===

=== Starting test "ChildProcess run errs when starting twice - unix" ===
Running command: /tmp/aws-toolkit-vscode/vsctkqk8YEx/test-script.sh 
=== Ending test "ChildProcess run errs when starting twice - unix" ===

=== Starting test "ChildProcess run runs scripts containing a space in the filename and folder" ===
Running command: /tmp/aws-toolkit-vscode/vsctkNUk3u9/sub folder/test script.sh 
=== Ending test "ChildProcess run runs scripts containing a space in the filename and folder" ===

=== Starting test "ChildProcess run reports error for missing executable" ===
Running command: /tmp/aws-toolkit-vscode/vsctkECQ2oL/nonExistentScript 
=== Ending test "ChildProcess run reports error for missing executable" ===

=== Starting test "ChildProcess start runs and captures stdout - unix" ===
Running command: /tmp/aws-toolkit-vscode/vsctkN77Kmn/test-script.sh 
=== Ending test "ChildProcess start runs and captures stdout - unix" ===

=== Starting test "ChildProcess start errs when starting twice - unix" ===
Running command: /tmp/aws-toolkit-vscode/vsctkchoQoZ/test-script.sh 
=== Ending test "ChildProcess start errs when starting twice - unix" ===

=== Starting test "ChildProcess start runs scripts containing a space in the filename and folder" ===
Running command: /tmp/aws-toolkit-vscode/vsctkFTovuB/sub folder/test script.sh 
=== Ending test "ChildProcess start runs scripts containing a space in the filename and folder" ===

=== Starting test "ChildProcess start reports error for missing executable" ===
Running command: /tmp/aws-toolkit-vscode/vsctke7IQDd/nonExistentScript 
=== Ending test "ChildProcess start reports error for missing executable" ===

=== Starting test "ChildProcess kill & killed detects running processes and successfully sends a kill signal to a running process - Unix" ===
Running command: /tmp/aws-toolkit-vscode/vsctkner6RP/test-script.sh 
=== Ending test "ChildProcess kill & killed detects running processes and successfully sends a kill signal to a running process - Unix" ===

=== Starting test "ChildProcess kill & killed can not kill previously killed processes - Unix" ===
Running command: /tmp/aws-toolkit-vscode/vsctkWSM6ts/test-script.sh 
=== Ending test "ChildProcess kill & killed can not kill previously killed processes - Unix" ===

=== Starting test "CollectionUtils union returns an empty set if both inputs are empty" ===
=== Ending test "CollectionUtils union returns an empty set if both inputs are empty" ===

=== Starting test "CollectionUtils union includes all elements from both inputs" ===
=== Ending test "CollectionUtils union includes all elements from both inputs" ===

=== Starting test "CollectionUtils intersection returns an empty set if both insputs are empty" ===
=== Ending test "CollectionUtils intersection returns an empty set if both insputs are empty" ===

=== Starting test "CollectionUtils intersection returns an empty set if inputs have no elements in common" ===
=== Ending test "CollectionUtils intersection returns an empty set if inputs have no elements in common" ===

=== Starting test "CollectionUtils intersection returns only elements that are present in both inputs" ===
=== Ending test "CollectionUtils intersection returns only elements that are present in both inputs" ===

=== Starting test "CollectionUtils difference returns an empty set if the first input is empty" ===
=== Ending test "CollectionUtils difference returns an empty set if the first input is empty" ===

=== Starting test "CollectionUtils difference returns the elements in the first input if the second input is empty" ===
=== Ending test "CollectionUtils difference returns the elements in the first input if the second input is empty" ===

=== Starting test "CollectionUtils difference does not return elements that are present in the second input" ===
=== Ending test "CollectionUtils difference does not return elements that are present in the second input" ===

=== Starting test "CollectionUtils complement returns an empty set if the second input is empty" ===
=== Ending test "CollectionUtils complement returns an empty set if the second input is empty" ===

=== Starting test "CollectionUtils complement returns the elements in the second input if the first input is empty" ===
=== Ending test "CollectionUtils complement returns the elements in the second input if the first input is empty" ===

=== Starting test "CollectionUtils complement does not return elements that are present in the first input" ===
=== Ending test "CollectionUtils complement does not return elements that are present in the first input" ===

=== Starting test "CollectionUtils toArrayAsync returns an empty array if input is empty" ===
=== Ending test "CollectionUtils toArrayAsync returns an empty array if input is empty" ===

=== Starting test "CollectionUtils toArrayAsync returns each item in input" ===
=== Ending test "CollectionUtils toArrayAsync returns each item in input" ===

=== Starting test "CollectionUtils toMap returns an empty map if the input is empty" ===
=== Ending test "CollectionUtils toMap returns an empty map if the input is empty" ===

=== Starting test "CollectionUtils toMap uses selector to choose keys" ===
=== Ending test "CollectionUtils toMap uses selector to choose keys" ===

=== Starting test "CollectionUtils toMap throws an error on duplicate keys" ===
=== Ending test "CollectionUtils toMap throws an error on duplicate keys" ===

=== Starting test "CollectionUtils toMapAsync returns an empty map if the input is empty" ===
=== Ending test "CollectionUtils toMapAsync returns an empty map if the input is empty" ===

=== Starting test "CollectionUtils toMapAsync uses selector to choose keys" ===
=== Ending test "CollectionUtils toMapAsync uses selector to choose keys" ===

=== Starting test "CollectionUtils toMapAsync throws an error on duplicate keys" ===
=== Ending test "CollectionUtils toMapAsync throws an error on duplicate keys" ===

=== Starting test "CollectionUtils updateInPlace removes items that are present in the original map, but not the input" ===
=== Ending test "CollectionUtils updateInPlace removes items that are present in the original map, but not the input" ===

=== Starting test "CollectionUtils updateInPlace updates items that are present in both the original map and the input" ===
=== Ending test "CollectionUtils updateInPlace updates items that are present in both the original map and the input" ===

=== Starting test "CollectionUtils updateInPlace adds items that are present in the input, but not the original map" ===
=== Ending test "CollectionUtils updateInPlace adds items that are present in the input, but not the original map" ===

=== Starting test "CollectionUtils first returns the first item the sequence is not empty" ===
=== Ending test "CollectionUtils first returns the first item the sequence is not empty" ===

=== Starting test "CollectionUtils first returns undefined if the sequence is empty" ===
=== Ending test "CollectionUtils first returns undefined if the sequence is empty" ===

=== Starting test "CollectionUtils first lazily iterates the sequence" ===
=== Ending test "CollectionUtils first lazily iterates the sequence" ===

=== Starting test "CollectionUtils take returns the first <count> items if sequence contains at least that many items" ===
=== Ending test "CollectionUtils take returns the first <count> items if sequence contains at least that many items" ===

=== Starting test "CollectionUtils take returns the first <sequence.length> items if sequence contains fewer than <count> items" ===
=== Ending test "CollectionUtils take returns the first <sequence.length> items if sequence contains fewer than <count> items" ===

=== Starting test "CollectionUtils take returns an empty array if sequence is empty" ===
=== Ending test "CollectionUtils take returns an empty array if sequence is empty" ===

=== Starting test "CollectionUtils take returns an empty array if count is 0" ===
=== Ending test "CollectionUtils take returns an empty array if count is 0" ===

=== Starting test "CollectionUtils take lazily iterates the sequence" ===
=== Ending test "CollectionUtils take lazily iterates the sequence" ===

=== Starting test "CollectionUtils filter returns the original sequence filtered by the predicate" ===
=== Ending test "CollectionUtils filter returns the original sequence filtered by the predicate" ===

=== Starting test "CollectionUtils filterAsync returns the original sequence filtered by the predicate" ===
=== Ending test "CollectionUtils filterAsync returns the original sequence filtered by the predicate" ===

=== Starting test "DisposableFiles deletes file on dispose" ===
=== Ending test "DisposableFiles deletes file on dispose" ===

=== Starting test "DisposableFiles deletes folder on dispose" ===
=== Ending test "DisposableFiles deletes folder on dispose" ===

=== Starting test "DisposableFiles deletes folder containing contents on dispose" ===
=== Ending test "DisposableFiles deletes folder containing contents on dispose" ===

=== Starting test "DisposableFiles is okay deleting a parent folder before a child folder" ===
=== Ending test "DisposableFiles is okay deleting a parent folder before a child folder" ===

=== Starting test "ExtensionDisposableFiles getInstance throws error if not initialized" ===
=== Ending test "ExtensionDisposableFiles getInstance throws error if not initialized" ===

=== Starting test "ExtensionDisposableFiles cannot be initialized twice" ===
=== Ending test "ExtensionDisposableFiles cannot be initialized twice" ===

=== Starting test "ExtensionDisposableFiles creates temp folder on initialization" ===
=== Ending test "ExtensionDisposableFiles creates temp folder on initialization" ===

=== Starting test "getNormalizedRelativePath returns expected path" ===
=== Ending test "getNormalizedRelativePath returns expected path" ===

=== Starting test "normalizeSeparator normalizes separators" ===
=== Ending test "normalizeSeparator normalizes separators" ===

=== Starting test "dirnameWithTrailingSlash Adds a trailing slash to a parent folder" ===
=== Ending test "dirnameWithTrailingSlash Adds a trailing slash to a parent folder" ===

=== Starting test "PromiseSharer joins promises" ===
=== Ending test "PromiseSharer joins promises" ===

=== Starting test "PromiseSharer does not join different promises" ===
=== Ending test "PromiseSharer does not join different promises" ===

=== Starting test "PromiseSharer starts a new promise if previous one completed" ===
=== Ending test "PromiseSharer starts a new promise if previous one completed" ===

=== Starting test "symbolUtilities loadSymbols returns symbols if available" ===
=== Ending test "symbolUtilities loadSymbols returns symbols if available" ===

=== Starting test "symbolUtilities loadSymbols does not retry if maxRetries is 0" ===
=== Ending test "symbolUtilities loadSymbols does not retry if maxRetries is 0" ===

=== Starting test "symbolUtilities loadSymbols retries if maxRetries is non-zero" ===
=== Ending test "symbolUtilities loadSymbols retries if maxRetries is non-zero" ===

=== Starting test "symbolUtilities loadSymbols returns undefined if all retries fail" ===
=== Ending test "symbolUtilities loadSymbols returns undefined if all retries fail" ===

=== Starting test "symbolUtilities getChildrenRange returns the range for the child if exactly one child is found" ===
=== Ending test "symbolUtilities getChildrenRange returns the range for the child if exactly one child is found" ===

=== Starting test "symbolUtilities getChildrenRange returns the range for all children if multiple children are found" ===
=== Ending test "symbolUtilities getChildrenRange returns the range for all children if multiple children are found" ===

=== Starting test "symbolUtilities getChildrenRange returns the range for the entire symbol if no children are found" ===
=== Ending test "symbolUtilities getChildrenRange returns the range for the entire symbol if no children are found" ===

=== Starting test "removeAnsi removes ansi code from text" ===
=== Ending test "removeAnsi removes ansi code from text" ===

=== Starting test "removeAnsi text without ansi code remains as-is" ===
=== Ending test "removeAnsi text without ansi code remains as-is" ===

=== Starting test "getStringHash produces a hash" ===
=== Ending test "getStringHash produces a hash" ===

=== Starting test "getStringHash produces a different hash for different strings" ===
=== Ending test "getStringHash produces a different hash for different strings" ===

=== Starting test "timeoutUtils Timeout returns > 0 if the timer is still active" ===
=== Ending test "timeoutUtils Timeout returns > 0 if the timer is still active" ===

=== Starting test "timeoutUtils Timeout returns 0 if timer is expired" ===
=== Ending test "timeoutUtils Timeout returns 0 if timer is expired" ===

=== Starting test "timeoutUtils Timeout returns a Promise if a timer is active" ===
=== Ending test "timeoutUtils Timeout returns a Promise if a timer is active" ===

=== Starting test "timeoutUtils Timeout timer object rejects if a timer is expired" ===
=== Ending test "timeoutUtils Timeout timer object rejects if a timer is expired" ===

=== Starting test "timeoutUtils Timeout successfully kills active timers" ===
=== Ending test "timeoutUtils Timeout successfully kills active timers" ===

=== Starting test "timeoutUtils Timeout correctly reports an elapsed time" ===
=== Ending test "timeoutUtils Timeout correctly reports an elapsed time" ===

=== Starting test "getChannelLogger should expose output channel" ===
=== Ending test "getChannelLogger should expose output channel" ===

=== Starting test "getChannelLogger log level verbose logs w/o template params writes to the logger" ===
Yay
=== Ending test "getChannelLogger log level verbose logs w/o template params writes to the logger" ===

=== Starting test "getChannelLogger log level verbose logs w/o template params writes to the output channel" ===
Yay
=== Ending test "getChannelLogger log level verbose logs w/o template params writes to the output channel" ===

=== Starting test "getChannelLogger log level verbose logs w/o template params processTemplate handles this scenario" ===
Yay
=== Ending test "getChannelLogger log level verbose logs w/o template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level verbose logs with 1 string template param writes to the logger" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level verbose logs with 1 string template param writes to the logger" ===

=== Starting test "getChannelLogger log level verbose logs with 1 string template param writes to the output channel" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level verbose logs with 1 string template param writes to the output channel" ===

=== Starting test "getChannelLogger log level verbose logs with 1 string template param processTemplate handles this scenario" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level verbose logs with 1 string template param processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level verbose logs with 2 string template params writes to the logger" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level verbose logs with 2 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level verbose logs with 2 string template params writes to the output channel" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level verbose logs with 2 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level verbose logs with 2 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level verbose logs with 2 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level verbose logs with 3 string template params writes to the logger" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level verbose logs with 3 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level verbose logs with 3 string template params writes to the output channel" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level verbose logs with 3 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level verbose logs with 3 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level verbose logs with 3 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level verbose logs with 2 template params: errro, string writes to the logger" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level verbose logs with 2 template params: errro, string writes to the logger" ===

=== Starting test "getChannelLogger log level verbose logs with 2 template params: errro, string writes to the output channel" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level verbose logs with 2 template params: errro, string writes to the output channel" ===

=== Starting test "getChannelLogger log level verbose logs with 2 template params: errro, string processTemplate handles this scenario" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level verbose logs with 2 template params: errro, string processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level verbose logs with 2 template params: error, error writes to the logger" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level verbose logs with 2 template params: error, error writes to the logger" ===

=== Starting test "getChannelLogger log level verbose logs with 2 template params: error, error writes to the output channel" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level verbose logs with 2 template params: error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level verbose logs with 2 template params: error, error processTemplate handles this scenario" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level verbose logs with 2 template params: error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level verbose logs with 3 template params: string, error, error writes to the logger" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level verbose logs with 3 template params: string, error, error writes to the logger" ===

=== Starting test "getChannelLogger log level verbose logs with 3 template params: string, error, error writes to the output channel" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level verbose logs with 3 template params: string, error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level verbose logs with 3 template params: string, error, error processTemplate handles this scenario" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level verbose logs with 3 template params: string, error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level debug logs w/o template params writes to the logger" ===
Yay
=== Ending test "getChannelLogger log level debug logs w/o template params writes to the logger" ===

=== Starting test "getChannelLogger log level debug logs w/o template params writes to the output channel" ===
Yay
=== Ending test "getChannelLogger log level debug logs w/o template params writes to the output channel" ===

=== Starting test "getChannelLogger log level debug logs w/o template params processTemplate handles this scenario" ===
Yay
=== Ending test "getChannelLogger log level debug logs w/o template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level debug logs with 1 string template param writes to the logger" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level debug logs with 1 string template param writes to the logger" ===

=== Starting test "getChannelLogger log level debug logs with 1 string template param writes to the output channel" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level debug logs with 1 string template param writes to the output channel" ===

=== Starting test "getChannelLogger log level debug logs with 1 string template param processTemplate handles this scenario" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level debug logs with 1 string template param processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level debug logs with 2 string template params writes to the logger" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level debug logs with 2 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level debug logs with 2 string template params writes to the output channel" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level debug logs with 2 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level debug logs with 2 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level debug logs with 2 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level debug logs with 3 string template params writes to the logger" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level debug logs with 3 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level debug logs with 3 string template params writes to the output channel" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level debug logs with 3 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level debug logs with 3 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level debug logs with 3 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level debug logs with 2 template params: errro, string writes to the logger" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level debug logs with 2 template params: errro, string writes to the logger" ===

=== Starting test "getChannelLogger log level debug logs with 2 template params: errro, string writes to the output channel" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level debug logs with 2 template params: errro, string writes to the output channel" ===

=== Starting test "getChannelLogger log level debug logs with 2 template params: errro, string processTemplate handles this scenario" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level debug logs with 2 template params: errro, string processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level debug logs with 2 template params: error, error writes to the logger" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level debug logs with 2 template params: error, error writes to the logger" ===

=== Starting test "getChannelLogger log level debug logs with 2 template params: error, error writes to the output channel" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level debug logs with 2 template params: error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level debug logs with 2 template params: error, error processTemplate handles this scenario" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level debug logs with 2 template params: error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level debug logs with 3 template params: string, error, error writes to the logger" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level debug logs with 3 template params: string, error, error writes to the logger" ===

=== Starting test "getChannelLogger log level debug logs with 3 template params: string, error, error writes to the output channel" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level debug logs with 3 template params: string, error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level debug logs with 3 template params: string, error, error processTemplate handles this scenario" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level debug logs with 3 template params: string, error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level info logs w/o template params writes to the logger" ===
Yay
=== Ending test "getChannelLogger log level info logs w/o template params writes to the logger" ===

=== Starting test "getChannelLogger log level info logs w/o template params writes to the output channel" ===
Yay
=== Ending test "getChannelLogger log level info logs w/o template params writes to the output channel" ===

=== Starting test "getChannelLogger log level info logs w/o template params processTemplate handles this scenario" ===
Yay
=== Ending test "getChannelLogger log level info logs w/o template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level info logs with 1 string template param writes to the logger" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level info logs with 1 string template param writes to the logger" ===

=== Starting test "getChannelLogger log level info logs with 1 string template param writes to the output channel" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level info logs with 1 string template param writes to the output channel" ===

=== Starting test "getChannelLogger log level info logs with 1 string template param processTemplate handles this scenario" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level info logs with 1 string template param processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level info logs with 2 string template params writes to the logger" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level info logs with 2 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level info logs with 2 string template params writes to the output channel" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level info logs with 2 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level info logs with 2 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level info logs with 2 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level info logs with 3 string template params writes to the logger" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level info logs with 3 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level info logs with 3 string template params writes to the output channel" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level info logs with 3 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level info logs with 3 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level info logs with 3 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level info logs with 2 template params: errro, string writes to the logger" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level info logs with 2 template params: errro, string writes to the logger" ===

=== Starting test "getChannelLogger log level info logs with 2 template params: errro, string writes to the output channel" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level info logs with 2 template params: errro, string writes to the output channel" ===

=== Starting test "getChannelLogger log level info logs with 2 template params: errro, string processTemplate handles this scenario" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level info logs with 2 template params: errro, string processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level info logs with 2 template params: error, error writes to the logger" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level info logs with 2 template params: error, error writes to the logger" ===

=== Starting test "getChannelLogger log level info logs with 2 template params: error, error writes to the output channel" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level info logs with 2 template params: error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level info logs with 2 template params: error, error processTemplate handles this scenario" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level info logs with 2 template params: error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level info logs with 3 template params: string, error, error writes to the logger" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level info logs with 3 template params: string, error, error writes to the logger" ===

=== Starting test "getChannelLogger log level info logs with 3 template params: string, error, error writes to the output channel" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level info logs with 3 template params: string, error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level info logs with 3 template params: string, error, error processTemplate handles this scenario" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level info logs with 3 template params: string, error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level warn logs w/o template params writes to the logger" ===
Yay
=== Ending test "getChannelLogger log level warn logs w/o template params writes to the logger" ===

=== Starting test "getChannelLogger log level warn logs w/o template params writes to the output channel" ===
Yay
=== Ending test "getChannelLogger log level warn logs w/o template params writes to the output channel" ===

=== Starting test "getChannelLogger log level warn logs w/o template params processTemplate handles this scenario" ===
Yay
=== Ending test "getChannelLogger log level warn logs w/o template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level warn logs with 1 string template param writes to the logger" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level warn logs with 1 string template param writes to the logger" ===

=== Starting test "getChannelLogger log level warn logs with 1 string template param writes to the output channel" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level warn logs with 1 string template param writes to the output channel" ===

=== Starting test "getChannelLogger log level warn logs with 1 string template param processTemplate handles this scenario" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level warn logs with 1 string template param processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level warn logs with 2 string template params writes to the logger" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level warn logs with 2 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level warn logs with 2 string template params writes to the output channel" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level warn logs with 2 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level warn logs with 2 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level warn logs with 2 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level warn logs with 3 string template params writes to the logger" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level warn logs with 3 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level warn logs with 3 string template params writes to the output channel" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level warn logs with 3 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level warn logs with 3 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level warn logs with 3 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level warn logs with 2 template params: errro, string writes to the logger" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level warn logs with 2 template params: errro, string writes to the logger" ===

=== Starting test "getChannelLogger log level warn logs with 2 template params: errro, string writes to the output channel" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level warn logs with 2 template params: errro, string writes to the output channel" ===

=== Starting test "getChannelLogger log level warn logs with 2 template params: errro, string processTemplate handles this scenario" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level warn logs with 2 template params: errro, string processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level warn logs with 2 template params: error, error writes to the logger" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level warn logs with 2 template params: error, error writes to the logger" ===

=== Starting test "getChannelLogger log level warn logs with 2 template params: error, error writes to the output channel" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level warn logs with 2 template params: error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level warn logs with 2 template params: error, error processTemplate handles this scenario" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level warn logs with 2 template params: error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level warn logs with 3 template params: string, error, error writes to the logger" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level warn logs with 3 template params: string, error, error writes to the logger" ===

=== Starting test "getChannelLogger log level warn logs with 3 template params: string, error, error writes to the output channel" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level warn logs with 3 template params: string, error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level warn logs with 3 template params: string, error, error processTemplate handles this scenario" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level warn logs with 3 template params: string, error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level error logs w/o template params writes to the logger" ===
Yay
=== Ending test "getChannelLogger log level error logs w/o template params writes to the logger" ===

=== Starting test "getChannelLogger log level error logs w/o template params writes to the output channel" ===
Yay
=== Ending test "getChannelLogger log level error logs w/o template params writes to the output channel" ===

=== Starting test "getChannelLogger log level error logs w/o template params processTemplate handles this scenario" ===
Yay
=== Ending test "getChannelLogger log level error logs w/o template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level error logs with 1 string template param writes to the logger" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level error logs with 1 string template param writes to the logger" ===

=== Starting test "getChannelLogger log level error logs with 1 string template param writes to the output channel" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level error logs with 1 string template param writes to the output channel" ===

=== Starting test "getChannelLogger log level error logs with 1 string template param processTemplate handles this scenario" ===
Nice to meet you 'bob'
=== Ending test "getChannelLogger log level error logs with 1 string template param processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level error logs with 2 string template params writes to the logger" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level error logs with 2 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level error logs with 2 string template params writes to the output channel" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level error logs with 2 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level error logs with 2 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe'
=== Ending test "getChannelLogger log level error logs with 2 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level error logs with 3 string template params writes to the logger" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level error logs with 3 string template params writes to the logger" ===

=== Starting test "getChannelLogger log level error logs with 3 string template params writes to the output channel" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level error logs with 3 string template params writes to the output channel" ===

=== Starting test "getChannelLogger log level error logs with 3 string template params processTemplate handles this scenario" ===
Hey 'bob', meet 'joe' and 'kim
=== Ending test "getChannelLogger log level error logs with 3 string template params processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level error logs with 2 template params: errro, string writes to the logger" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level error logs with 2 template params: errro, string writes to the logger" ===

=== Starting test "getChannelLogger log level error logs with 2 template params: errro, string writes to the output channel" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level error logs with 2 template params: errro, string writes to the output channel" ===

=== Starting test "getChannelLogger log level error logs with 2 template params: errro, string processTemplate handles this scenario" ===
Oh no 'joe', we found an error: 'Stock market crash'
Error: Stock market crash
=== Ending test "getChannelLogger log level error logs with 2 template params: errro, string processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level error logs with 2 template params: error, error writes to the logger" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level error logs with 2 template params: error, error writes to the logger" ===

=== Starting test "getChannelLogger log level error logs with 2 template params: error, error writes to the output channel" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level error logs with 2 template params: error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level error logs with 2 template params: error, error processTemplate handles this scenario" ===
1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level error logs with 2 template params: error, error processTemplate handles this scenario" ===

=== Starting test "getChannelLogger log level error logs with 3 template params: string, error, error writes to the logger" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level error logs with 3 template params: string, error, error writes to the logger" ===

=== Starting test "getChannelLogger log level error logs with 3 template params: string, error, error writes to the output channel" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level error logs with 3 template params: string, error, error writes to the output channel" ===

=== Starting test "getChannelLogger log level error logs with 3 template params: string, error, error processTemplate handles this scenario" ===
Oh my 'Bob', there are errors: 1st Error 'Error zero'; 2nd error: 'Error one'
Error: Error zero
Error: Error one
=== Ending test "getChannelLogger log level error logs with 3 template params: string, error, error processTemplate handles this scenario" ===

=== Starting test "StepFunctionsNode returns placeholder node if no children are present" ===
=== Ending test "StepFunctionsNode returns placeholder node if no children are present" ===

=== Starting test "StepFunctionsNode has StateMachineNode child nodes" ===
=== Ending test "StepFunctionsNode has StateMachineNode child nodes" ===

=== Starting test "StepFunctionsNode has child nodes with State Machine contextValue" ===
=== Ending test "StepFunctionsNode has child nodes with State Machine contextValue" ===

=== Starting test "StepFunctionsNode sorts child nodes" ===
=== Ending test "StepFunctionsNode sorts child nodes" ===

=== Starting test "StepFunctionsNode has an error node for a child if an error happens during loading" ===
Error while getting Child nodes: Update Children error!
=== Ending test "StepFunctionsNode has an error node for a child if an error happens during loading" ===

=== Starting test "StateMachineGraphCache updateCachedFile downloads a file when it is not in cache and stores it" ===
=== Ending test "StateMachineGraphCache updateCachedFile downloads a file when it is not in cache and stores it" ===

=== Starting test "StateMachineGraphCache updateCachedFile downloads and stores a file when cached file exists but url has been updated" ===
=== Ending test "StateMachineGraphCache updateCachedFile downloads and stores a file when cached file exists but url has been updated" ===

=== Starting test "StateMachineGraphCache updateCachedFile it does not store data when file exists and url for it is same" ===
=== Ending test "StateMachineGraphCache updateCachedFile it does not store data when file exists and url for it is same" ===

=== Starting test "StateMachineGraphCache updateCachedFile creates assets directory when it does not exist" ===
Folder for graphing script and styling doesnt exist. Creating it.
=== Ending test "StateMachineGraphCache updateCachedFile creates assets directory when it does not exist" ===

=== Starting test "isStepFunctionsRole return true if the Step Functions service principal is in the AssumeRolePolicyDocument" ===
=== Ending test "isStepFunctionsRole return true if the Step Functions service principal is in the AssumeRolePolicyDocument" ===

=== Starting test "isStepFunctionsRole returns false if the role does not have an AssumeRolePolicyDocument" ===
=== Ending test "isStepFunctionsRole returns false if the role does not have an AssumeRolePolicyDocument" ===

=== Starting test "isStepFunctionsRole returns false if the AssumeRolePolicyDocument does not contain Step Functions' service principal" ===
=== Ending test "isStepFunctionsRole returns false if the AssumeRolePolicyDocument does not contain Step Functions' service principal" ===

=== Starting test "PublishStateMachineWizard PUBLISH_ACTION exits when cancelled" ===
=== Ending test "PublishStateMachineWizard PUBLISH_ACTION exits when cancelled" ===

=== Starting test "PublishStateMachineWizard Quick create exits gracefully if cancelled" ===
=== Ending test "PublishStateMachineWizard Quick create exits gracefully if cancelled" ===

=== Starting test "PublishStateMachineWizard Quick create returns create response when completed" ===
=== Ending test "PublishStateMachineWizard Quick create returns create response when completed" ===

=== Starting test "PublishStateMachineWizard Quick update exits gracefully if cancelled" ===
=== Ending test "PublishStateMachineWizard Quick update exits gracefully if cancelled" ===

=== Starting test "PublishStateMachineWizard Quick update returns update response when completed" ===
=== Ending test "PublishStateMachineWizard Quick update returns update response when completed" ===

=== Starting test "SamTemplateGenerator Produces a minimal template" ===
=== Ending test "SamTemplateGenerator Produces a minimal template" ===

=== Starting test "SamTemplateGenerator Produces a template containing MemorySize" ===
=== Ending test "SamTemplateGenerator Produces a template containing MemorySize" ===

=== Starting test "SamTemplateGenerator Produces a template containing Timeout" ===
=== Ending test "SamTemplateGenerator Produces a template containing Timeout" ===

=== Starting test "SamTemplateGenerator Produces a template containing Environment" ===
=== Ending test "SamTemplateGenerator Produces a template containing Environment" ===

=== Starting test "SamTemplateGenerator Produces a template with a Globals section" ===
=== Ending test "SamTemplateGenerator Produces a template with a Globals section" ===

=== Starting test "SamTemplateGenerator errs if resource name is missing" ===
=== Ending test "SamTemplateGenerator errs if resource name is missing" ===

=== Starting test "SamTemplateGenerator errs if function handler is missing" ===
=== Ending test "SamTemplateGenerator errs if function handler is missing" ===

=== Starting test "SamTemplateGenerator errs if code uri is missing" ===
=== Ending test "SamTemplateGenerator errs if code uri is missing" ===

=== Starting test "SamTemplateGenerator errs if runtime is missing" ===
=== Ending test "SamTemplateGenerator errs if runtime is missing" ===

=== Starting test "TypescriptLambdaHandlerSearch finds export declared functions in Typescript code" ===
=== Ending test "TypescriptLambdaHandlerSearch finds export declared functions in Typescript code" ===

=== Starting test "TypescriptLambdaHandlerSearch ignores class declarations in Typescript code" ===
=== Ending test "TypescriptLambdaHandlerSearch ignores class declarations in Typescript code" ===

=== Starting test "TypescriptLambdaHandlerSearch ignores interface declarations in Typescript code" ===
=== Ending test "TypescriptLambdaHandlerSearch ignores interface declarations in Typescript code" ===

=== Starting test "TypescriptLambdaHandlerSearch finds module.exports declared functions in javascript code" ===
=== Ending test "TypescriptLambdaHandlerSearch finds module.exports declared functions in javascript code" ===

=== Starting test "TypescriptLambdaHandlerSearch ignores class declarations in javascript code" ===
=== Ending test "TypescriptLambdaHandlerSearch ignores class declarations in javascript code" ===

=== Starting test "region uses user response as region" ===
=== Ending test "region uses user response as region" ===

=== Starting test "region backtracks when cancelled" ===
=== Ending test "region backtracks when cancelled" ===

=== Starting test "registry uses user response as registry" ===
=== Ending test "registry uses user response as registry" ===

=== Starting test "registry backtracks when cancelled" ===
=== Ending test "registry backtracks when cancelled" ===

=== Starting test "schema uses user response as schema" ===
=== Ending test "schema uses user response as schema" ===

=== Starting test "schema backtracks when cancelled" ===
=== Ending test "schema backtracks when cancelled" ===

=== Starting test "location uses user response as schema" ===
=== Ending test "location uses user response as schema" ===

=== Starting test "location backtracks when cancelled" ===
=== Ending test "location backtracks when cancelled" ===

